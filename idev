#!/bin/bash
# -*- shell-script -*-
#
#set -x
# User is forces to use either SGE or SLURM options, except
# -p and -q can both be used for either batch system
#
# For Stampede the system startup file /etc/profile.d/z95_idev.<csh|sh>
# takes care of sourcing /tmp/idev_<csh|sh>_env.<jobid> if the file
# exists, and exports the env. vars: IDEV_SETUP_BYPASS="1.0",
# idev_ip=cyxz-abc, idev_env_status=[0|1].
# If the sourcing file  exists in /tmp on the compute node 
# idev_env_status is set to 0, the file is sourced, shell cd's
# to $IDEV_PWD, and DDTMPIRUN=ibrun is exported.  This is called
# System Sourcing.

# If System Sourcing exists for the machine, IDEV_ENV_REPLICATION
# is exported as SYSTEM, and no user startup file (.profile, etc.)
# is instrumented to source an environment file.  This can be 
# bypassed by including:
#       IDEV_ENV_REPLICATION=USER
# in the .idevrc file.
# Note: For SYSTEM /tmp/idev_<csh|sh>_env.<jobid> is the sourcing file
#       For USER     /tmp/my_<csh|sh>_env.<jobid> is the sourcing file

# SLURM
# If user account becomes invalid, or single-project mode 
# is not longer valid (user acquires an additional project), 
# the idev_project line (default project) is removed from ~/.idevrc.
#                                                06/28/2013 KentM
#  if accounting is not on include "idev_project use_default" in ~/.idevrc.
# SLURM 
# Reservations can be requested. Users are queried
# about any active reservation-- do they want to use it. 
# Use "idev -r none" to avoid questions.
#                                                09/20/2013 KentM
# Remove SSH_xxx from environment
# Allow users to remove environment variables
# by adding idev_rm_env=<space-separated list of env vars>
#
# Eliminates PERL5LIB from idev environment when
# executing idev perl commands.
#                                                03/30/2015 KentM 
# Include setup for Wrangler
#                                                04/11/2015 KentM
# Adjustments for ls5
#   On nidxxxx service node, system type will be ls5
#   Remove returns BASH_FUNC_ functions. See env_replication routine.
#   Now uses $HOME/.slurm to hold job scripts
#   (use IDEV_KEEP_MY_JOB_DIR variable to save job scipt to directory)
#   zzz85_idev.sh and zzz85_idev.csh updated in /etc/profile.d
#Set up CpN for vis and gpu queue on ls5 -- change for stampede later
#Remove SHELL_STARTUP_DEBUG_T0 from environment variables on compute node.
#Use $CpN when determining Project from test batch launch (R.McLay req).
#Changed ls5 default queue to development (was normal)
#Inserted -A in ssh command (forwarding of authentication agent connection).
# set IDEV_KEEP_M_JOB_DIR to store idev job output other than $HOME/.slurm
#        
#                                                12/09/2015 KentM 
#
#Hidden grace-serial queue 
#   Added -p <queue_name> option to squeue (to see queue)
#   Allow -n 1 for default for grace-serial queue
#   Changed format from 9 to 15 for queue name (grace-serial is 12 chars)
#                                                01/29/2016 KentM 
#
#Added Support for Stampede 1.5
#  Queue list now available with "-queues"
#  Queue select for KNL with "-qselect".
#                                                06/14/2016 KentM 
#Made normal for default until in full production
#                                                07/14/2016 KentM 
#   Setup for Large mem cluster on ls5
#   All systems can use -qselect/-pselect and -queues
#
#   Fixed auto project.  If 2nd project added, user is
#   prompted for a default.  (Much cleaner way to do this now.)
#
#   Only file $HOME/.slurm/${JOB_NAME}.o%j is retained now.
#                                                 08/11/2016 Kent Milfeld
#
#   Defined sbatch function/alias for bash/tcsh in idev_utils.
#   States that sbatch is not allowed on compute nodes.
#                                                 08/30/2016  Kent Milfeld

#   /tmp/idev_${USER}_${idev_login_shell}_env.${JOBID} is the SOURCE file
#   Older machines use a old /etc/profile.d/z85_idev.sh/tcsh that sources
#   a SOURCE file with _${USER}.  This is controlled by Rober McClay.
#
#       uses _${USER} zfile prefix Compute node regex   
#              v      v             V                  
#        ls5  yes zzz85_  nid[0-9][0-9]    c[0-9]-c[0-9] lgmem[0-9][0-9]
#        knl  yes z85_ c[0-9][0-9][0-9]-[0-9][0-9][0-9]   vis[0-9]  visbig
#   wrangler  yes z85_ c[0-9][0-9][0-9]-[0-9][0-9][0-9]   vis[0-9]  visbig
#     hikari  yes z85_ c[0-9][0-9][0-9]-[0-9][0-9][0-9]
#   stampede  no  z85_ c[0-9][0-9][0-9]-[0-9][0-9][0-9]   vis[0-9]  visbig
#   maverick2 no  z85_ c[0-9][0-9][0-9]-[0-9][0-9][0-9]
#   maverick  no  z85_ c[0-9][0-9][0-9]-[0-9][0-9][0-9]   vis & gpu
#   stampede2          c[0-9][0-9][0-9]-[0-9][0-9][0-9]
#        ls6  yes z85_ c[0-9][0-9][0-9]-p0-9][0-9][0-9]

#   remove "c[0-9]-c[0-9]", this is wrong
#   
#   generic   yes z85_ c[0-9][0-9] nid[0-9][0-9] vis[0-9] visbig lgmem[0-9][0-9]

#   _${USER} file is now created on all machines
#   on stampede/maverick2 _${USER} file is copied to file without _${USER}
#                                                 08/30/2016  Kent Milfeld
#
#   All defaults are now printed at beginning (e.g. total tasks, # of nodes).
#   "Using ... x" is printed when default is changed by command line arg.
#                                                 09/06/2016  Kent Milfeld
#
#   Added options --tasks-per-node --ntasks-per-node and -tpn
#   Final option  -- allows non-conflicting SLURM options after --
#   Added new logic for -N enforcement
#   Enforce -N requirement when cmd line only uses -n or tasks-per-node.
#   For queues with Hyperthreaded compute nodes, request users to
#     select a default Tasks per Node (TpN) and save in .idevrc--
#     idev suggests to use Cores per Node (CpN) value.
#   " ->" is the official sentinel for an idev response

#   New format for resource report
# knl$ ./idev -N 2 -- w c562-033
# -> Defaults file    : ~/.idevrc   
# -> System           : knl         
# -> Queue            : normal        (idev  default       )  [If long wait, use development queue.    ]
# -> Nodes            : 2             (cmd line: -N        )
# -> Tasks per Node   : 68            (~/.idevrc           )
# -> Time (minutes)   : 30            (idev  default       )
# -> Project          : A-ccsc        (~/.idevrc           )
# -> SLURM options    : w c562-033    (cmd line: --        )
#
#  Don't export functions in zsh (e.g. function sbatch()). Reqested by R.McLay
#
#  If command line -p option supplied, and user is asked to accept a reservation,
#  advise user that -p option will be ignored (reservation must use queue of 
#  reserved nodes).  Requested by Lars Koesterke
#
#-> ** WARNING "-p <QUEUE> option will be ignored if you accept this reservation.
#->             Reservation uses queue of reserved nodes.
#->             Respond no if you want to use the <QUEUE> queue.
#
#                                                 02/15/2017  Kent Milfeld
#
#  Included logic to exit if idev execution is attempted on a compute node.
#                                                 04/10/2017  Kent Milfeld
#  If queue is not in "up" state, advise user.
#  Put back MANPATH variable on nodes.
#  If use has more than 1 active reservation, as for a selection.
#  Now there is a generic select_one (of these) function.
#  Print out reservation information in details of idev submission.
#  4 testing: IDEV_RESERVATION_TEST=yes; put scontrol show res in "reservation" file
#  fixed typos, rewording of reservation info (now that reservations are listed).
#
#                                                 07/09/2017  Kent Milfeld
#
#  If more than 2 ACTIVE reservation, now allow user to opt out of
#  using a reservation.
#  Advise users of rogue (old) version to use updated version.
#                                                 02/09/2018  Kent Milfeld
#
#  1.5.4 Moved reservation detection before "tpn" determination.
#  (Fixed Bug of reservation queue not considered in tpn determination.)
#                                                 04/13/2018  Kent Milfeld
#  Added default queue (normal) for wrangler      04/25/2018  Kent Milfeld
#  Added machine information for maverick         
#  Remove shell functions imported from front-end environment.
#  Let profile.d regenerate user function, LMOD regenerates its functions.
#                                                 09/06/2018  Kent Milfeld
#  Exit immediately after options determination if informational (-h|v)
#  or option error, so that "defaults" questioning is not performed.
#  Informational trap exit  processed without "graceful exit" notice.
#  http://redsymbol.net/articles/bash-exit-traps/
#                                                 03/12/2019  Kent Milfeld
#  Added Frontera
#                                                 09/06/2019  Kent Milfeld
#  Inserted Robert McLay's getopt parsing for options.  Uses can now
#  Can now specify option numbers wo space  (now -n1 works for -n 1)
#  Can use single or double "-" for long options (--qselect works for -qselect)
#  New options for job begin email
#  -e <e-address>   (-e now requires email address)
#  -E               (new, uses email address in ~./idevrc)
#
#                                                 09/09/2019  Kent Milfeld
#  -R added, not argument, Finds reservation for user
#                                                 09/10/2019  Kent Milfeld
#  Fixed END_DASH problem.
#  If an option requiring an argument is present without the option and
#  it followd by another option getopt thinks it is the argument.
#  (as in "idev -n  -N 2")
#  Quick and dirty fix: Each option requiring an argument tests to make sure 
#  the next $@ value starts witht "-".  If there is, a break in argument 
#  processing occurs, the error is report, and an exit occurs.
#
#  These args are hardcoded in ssh batch into compute node:
#  -Y -o "StrictHostKeyChecking no" 
#  There is a -A argument that is there by default (MY_SSH_ARGS="-A")
#  This can be changed by setting IDEV_SSH_ARGS
#  IDEV_SSH_ARGS="<args>" forces MY_SSH_ARGS to be "<args>" ("" allowed).
#  IDEV_SSH_ARGS="default <args>" makes args the new default
#  ("default" is allowed). Default value can be set as idev_ssh_args in .idevrc)
#  Note, "" or "default" allows for a default of no argument.
#                                                 10/01/2019  Kent Milfeld
#  Added Lonestar6 and commented out ls5 code
#                                                 09/24/2021  Kent Milfeld
#  1.6.0:
#  Fixed select_one (to use correct defaults)
#  Fixed check_project specifier.
#  Reservation are evaluated for projects.
#     If $USER found in user field, user's default account is used.
#     -- no other checking is performed.
#     If one of the user's accounts is found in the project field,
#     the first one is selected, and used when the reservation is seleccted.
#                                                 09/25/2021  Kent Milfeld
#  idev_time keyword in .idevrc now accepts HH:MM:SS format for time
#  in addition to the integer minute format.
#  Removed old notice about not compiling on compute nodes on stampede.
#  Set ls6 default queue to normal, 256, 128 max and suggested procs.
#                                                 10/12/2021  Kent Milfeld
#
#------------------------------------------------------------------------------
#
#               Versions Number
   IDEV_VER=1.6.0

   IDEV_SYM="->"
   TACC_SUPPORTED_SYSTEM="stampede2, ls6, wrangler, hikari, maverick2, frontera longhorn"
                                                                        #requires user define default total tasks
   SYSTEMS_REQUIRE_USER_DEFINE_n=(   knl,      ls6      stampede2       hikari      wrangler      frontera       longhorn)
   SYSTEMS_MAX_USER_DEFINE_n=(      [knl]=272 [ls6]=256 [stampede2]=272 [hikari]=48 [wrangler]=48 [frontera]=112 [longhorn]=160)
   SYSTEMS_SUGGESTED_USER_DEFINE_n=([knl]=68  [ls6]=128 [stampede2]=68  [kikari]=24 [wrangler]=24 [frontera]=56  [longhorn]=40)

   DOTHIS="#"  # comment out cp cmd in job script. Old z85_ scripts need file without
               # $USER in name-- line is activated with DOTHIS="" for stampede/maverick2


#Determine the system
  myhostname=`hostname -f`
  MY_SYS=`echo $myhostname | awk 'BEGIN { FS = "." } ; { print $2 }'`

                                         #Check for KNL system on xxxx.stampeded.tacc.utexas.edu
  if [[ $MY_SYS == stampede ]] ; then    #xxxx will be login#-knl or c561-xxxx or greater
     first_name=`echo $myhostname | awk 'BEGIN { FS = "." } ; { print $1 }'` 
     if [[ $first_name =~ c[5-9][6-9][1-9] || $first_name =~ login-knl[1-9] ]]; then
        MY_SYS=knl
     fi
  fi



  srun=off        # Don't use srun on Stampede
# trap ctrl-c and call ctrl_c()
trap ctrl_c INT EXIT
did_exit=no
exit_msg=""

#RESOURCE SELECTION  begin
# Uh!!! ls5 uses bash 3.2.51, everybody else has moved on to 4. Cannot use associative arrays to get numbers  ${pr_no_sys}
#  declare -A rl_no=( ["sys"]="0" ["que"]="1" ["N"]="2" ["tpn"]="3" ["n"]="4" ["tm"]="5" ["A"]="6" ["rc"]="7" ["e"]="8" ["s"]="9" ["rv"]="10" ["sb"]="11")

 pr_no_sys=0;pr_no_que=1;pr_no_N=2;pr_no_tpn=3;pr_no_n=4;pr_no_tm=5;pr_no_A=6;pr_no_rc=7;pr_no_e=8;pr_no_s=9;pr_no_rv=10;pr_no_sb=11;
pr_no_rc=0;pr_no_sys=1;pr_no_que=2;pr_no_N=3; pr_no_tpn=4;pr_no_n=5;pr_no_tm=6;pr_no_A=7;pr_no_e=8;pr_no_s=9;pr_no_rv=10;pr_no_sb=11;
pr_no_rc=0;pr_no_sys=1;pr_no_res=2;pr_no_que=3;pr_no_N=4; pr_no_tpn=5;pr_no_n=6;pr_no_tm=7;pr_no_A=8;pr_no_e=9;pr_no_s=10;pr_no_rv=11;pr_no_sb=12;

                           # Standard formats for resources  2/3 = 2/3 args; "l" = long "e" email
#   res_format4=' -> %-17.17s: %-12.12s  (%-20.20s)  [%-40.40s]'
#   res_format3=' -> %-17.17s: %-12.12s  (%-20.20s)'
#  res_format3e=' -> %-17.17s: %-40.40s  (%-20.20s)'
#  res_format3l=' -> %-17.17s: %-12.12s  (%-27.27s)'
#   res_format2=' -> %-17.17s: %-12.12s'
#  res_format2l=' -> %-17.17s: %-50.50s'

    res_format4=' -> %-17.17s: %-13.13s  (%-20.20s)  [%-40.40s]'
    res_format3=' -> %-17.17s: %-13.13s  (%-20.20s)'
   res_format3e=' -> %-17.17s: %-41.41s  (%-20.20s)'
   res_format3l=' -> %-17.17s: %-13.13s  (%-27.27s)'
    res_format2=' -> %-17.17s: %-13.13s'
   res_format2l=' -> %-17.17s: %-51.51s'

                           # Strings for where the option value was obtained
          S_idevrc="~/.idevrc"
       S_Qdefault="queue default"
   S_idev_default="idev  default"
       S_cmd_line="cmd line:"
          S_space=" "
    S_reservation="reservation"
#RESOURCE SELECTION  end

                             # RES System listing
res_list[${pr_no_sys}]=`printf "$res_format2"  "System"          "$MY_SYS"`


#  TRAP Function.  Deletes job on exit of this script
function ctrl_c() {
                         #               Job submitted, and job id available.
        if [[ "x$job_submitted" = "xyes" && "x$job_id" != "xnone" ]]; then

                         #               Keeps from calling qdel twice. (why twice?)
           if [[ $did_exit == no ]]; then

             echo "Cleaning up: submitted job ($job_submitted) removing job $job_id."
             scancel $job_id

           fi
           did_exit=yes
           exit;
        fi
                         #Job submitted, but no job id yet.
        if [ "x$job_submitted" = "xyes" ]; then
           echo "Please control-c again, SLURM is responding slowly and I need a job ID for cleanup."
           echo "job_id:$job_id job_submitted:$job_submitted"
        else
                         #User control-c'd out before job launched.
           echo -e "$exit_msg"
          #echo -e " -> idev: no session created, gracefully exiting...\n"
           [[ "$do_exit" == "information_only" ]] && exit
           echo -e " -> idev command is ending with no interactive session created.\n"
           exit
        fi
} # END TRAP Function


# SELECTION Function
select_one(){
   # select_values          = array of values for selection

   # select_type            = string (e.g. queue, account, wait_or_exit,...)
   # selected_value_default = value  (default value if response is return)
   # selected_no_default    =  #     (number in the array for the default value, 1,...N)
   # selected_value         = 0,...,N-1

       select_count=${#select_values[@]}

   do_select=yes
   while [[ $do_select == yes ]]; do

       do_select=no                       #default, stop after 1 iteration

       echo " -> $select_type options are: "; echo ""

                #list options
       count=1;
       for i in ${select_values[@]}; do
         #echo "       $count $i"
          echo -e -n "      \033[1;36m$count"; echo -e -n '\033[0m'; echo " $i"
          (( count++ ))
       done

                #request a response
       if [[ $selected_no_default == "none" ]]; then
          echo -n  " -> Please type a NUMBER (no default for a return): ";
       else
          echo -n  " -> Please type a NUMBER or hit return (default=$selected_no_default): ";
       fi

       read    selected_no

       if [[ "$selected_no" == "" ]]; then selected_no=$selected_no_default; fi

                #determine what to do

                                              #re-do if inapproriate response
       if [[ ! (( $selected_no =~ ^[1-9]+$ ))  ||  (($selected_no -gt $select_count)) ]]; then
         if [[ "$selected_no" == "none" ]]; then
            echo ""; echo -e -n " -> \033[1;36mThat was not a valid response.";  echo -e -n '\033[0m'
            echo " You hit the return key. Try again.";  echo ""
            do_select=yes
         else
            echo ""; echo -e -n " -> \033[1;36mThat was not a valid response.";  echo -e -n '\033[0m'
            echo " You typed \"$selected_no\". Try again.";  echo ""
            do_select=yes
         fi
       fi
                                              #exit here if directed to
       [[ $selected_value == exit ]] && exit
                                              #continue on if not exit

                                              #list the valid response
       if [[ $do_select == no ]]; then
          selected_value=${select_values[ $(($selected_no-1)) ]}
          #echo " -> $selected_value is the \"$select_type\" value you selected."
          echo ""; echo "      $selected_value is the \"$select_type\" value you selected."; echo ""
       fi

   done
} # END SELECTION Function


#               Do the non-installation sensitive options here.


#               Intel port and server -- for using intel products on comp. nodes.
   my_intel_port_server=27000@troy.tacc.utexas.edu

###               @TACC copy intel license to .sge/intel
###               Intel license info:
##intel_license=intel.current.20120301.lic
## my_intel_dir=$HOME/.sge/intel
##    intel_dir=/opt/intel/licenses

#                 idev puts the default project in .idevrc
#                 pick it up here for the help option

                              # idev only uses first 5 digits of pid.
  my_pid=`printf "%05d" $$`   # fill with leading zeros if $$ is less than 5 digits

#                If two or more systems share a $HOME file system
#                create a distiguishing suffix for option within the ~/.idevrc
#                file.  (The first system my use the default (no suffix)
#                mechanism, if not included in the following hash)
#                @TACC stampede and stampedeknl share $HOME
#                     but stampede is not included-- stampede doesn't use this a suffix
#                     stampedeknl requires the "knl" suffix
#                           MY_SYS    Suffix
#                                 |    |
#                                 v    v
# declare -A mac_sharehome_id=( [knl]=knl )  # Implement this when ls5 goes to bash 4.x


#######################################################beg check for rogue (old) versions

                #If a production idev is in /usr/bin, check it against the version being used.
                #Ask user to use most recent verion (production), if reasonable.
  if [[ -f /usr/bin/idev && -z ${IDEV_SHUTDOWN_VERSION_CHECK} ]]; then
                  #Get the production idev version in /usr/bin (that might be $0, "myself")
     prod_IDEV_VER=`grep IDEV_VER= /usr/bin/idev | sed s/IDEV_VER=// | sed s'/ //'g`
  
                  #squash the three numbers together in units of 10000, 100 and 1
                  # e.g. 1.5.2 becomes 1*10000 + 5*100 + 2 (assumes none of the version elements will exceed 99.
     prod_cat_IDEV_VER=`echo $prod_IDEV_VER | awk '{split($0,A,".")} END{printf("%s",A[1]*10000+A[2]*100+A[3]) }'`
     this_cat_IDEV_VER=`echo      $IDEV_VER | awk '{split($0,A,".")} END{printf("%s",A[1]*10000+A[2]*100+A[3]) }'`
                  # Now, compare the squashed version numbers, and write notice if this code is out of date.
     if [[ $prod_cat_IDEV_VER > $this_cat_IDEV_VER ]]; then
        echo ""
        echo " $IDEV_SYM ***** NOTIFICATION  ***** NOTIFICATION  ***** NOTIFICATION ***** NOTIFICATION  *****"
        echo " $IDEV_SYM The production idev version ($prod_IDEV_VER) is newer than the version you are using ($IDEV_VER)."
        echo " $IDEV_SYM You might want/need to change over to the newest verion."
        echo ""
     fi
  fi

#######################################################end check for rogue (old) versions

#                 Defaults
  MY_MINUTES=30
  MY_hhmmss_TIME=00:${MY_MINUTES}:00
  MY_H_RT="h_rt=$MY_hhmmss_TIME"
#                                 Stampede1 requires a default set here
#                                 For other systems it is set in SYSTEM case selection below.
#TODO
    # if there is a development queue, use that
    #    However if wrangler, hikari, knl or ls5-bigmem
#TODO

#######################################################beg system options

  MY_QUEUE=development
  [[ $MY_SYS == "maverick2" ]]  && MY_QUEUE=gtx
  [[ $MY_SYS == "wrangler"  ]]  && MY_QUEUE=normal
  [[ $MY_SYS == "hikari"    ]]  && MY_QUEUE=normal
  [[ $MY_SYS == "knl"       ]]  && MY_QUEUE=normal
# [[ $MY_SYS == "stampede2" ]]  && MY_QUEUE=development
# [[ $MY_SYS == "ls5" && $TACC_SLURM_CONF =~ _LG  ]] && MY_QUEUE=largemem512GB
  [[ $MY_SYS == "ls6"       ]]  && MY_QUEUE=development
  [[ $MY_SYS == "maverick"  ]]  && MY_QUEUE=gpu
  [[ $MY_SYS == "longhorn"  ]]  && MY_QUEUE=development

#######################################################end system options


# Don't allow execution on compute nodes!
#                                          If on compute node, /tmp/idev_$USER... exists.

ls /tmp/idev_${USER}_bash_env.* >&/dev/null
if [[ $? == 0  ]]; then
   echo -e "\n -> ERROR:  You are trying to run idev on a compute node."
   echo -e   " ->         Execution of idev is only allowed on a login node."
   exit_msg=""
   exit 9
fi


  RESERVATION_CONTROL="NO_OPTION"
  RESERVATION_NAME=""
  MY_RESERVATION=""
  RESERVATION_USE=no
  MY_EMAIL=""
  opt_NODE_count=0
  opt_TASK_count=0
  opt_nodes=unset
  opt_tasks_per_node=unset
  opt_total_tasks=unset
  my_default_n=unset

JOB_NAME=idv${my_pid:(-5)}
monitor_sleep=4
sleep_after_run_factor=4
job_sleep=$(( MY_MINUTES * 60 ))


#                                          SSH to master node by default

     use_node_type=master
     insert_option=none
      IDEV_ACCOUNT="-A  willpromptyou"
        MY_ACCOUNT=none
     check_project=yes
   total_tasks_set=no
        queue_arch=standard
   list_node_queue=no
           qselect=no
    default_mac_no=1
        ls5_lrgmem=off    #ls5: has a largemem cluster with different queues
                                      #Make squeue look identical for ls5/stampede
   squeue_opts='-o %.18i %.15P %.9j %.8u %.2t %.10M %.6D %R' 
    MY_ADDRESS=none
    MY_TASKS_PER_NODE=unset
    MY_TOTAL_TASKS=unset
    MY_NODES=1
    IDEV_TASKS_PER_NODE=""
    IDEV_TOTAL_TASKS=""
    IDEV_SLURM_ARGS=""
    idevrc_tpn=unset

############################################beg  .idevrc options

                                      #Get option suffix used in .idevrc file
                                      #MID = Machine ID suffix
  MID=""
#                                     #implement when ls5 goes to bash 4.x
# for mac_key in "${!mac_sharehome_id[@]}"; do
#   [[ $MY_SYS ==  $mac_key ]] && MID=_${mac_sharehome_id[$mac_key]}
# done
  #FYI: if [ ${mac_share_home[missing]+_} ]; then echo "Found"; else echo "Not found"; fi

 [[ $MY_SYS == knl ]] && MID=_knl
 [[ $TACC_SLURM_CONF =~ _LG ]] && MID=_largemem


                             # RES resource file listing
res_list[${pr_no_rc}]=` printf "$res_format2"  "Defaults file"   "$S_idevrc"`


  if [ -e $HOME/.idevrc ]; then
#                                                 Get Project Name
     grep -Pq "idev_project${MID}\s" $HOME/.idevrc
     if [[ $? == 0 ]]; then                      #Pick up last occurence
        MY_ACCOUNT=`grep -P "idev_project${MID}\s" $HOME/.idevrc | tail -1 |sed "s/idev_project${MID}//"`
        MY_ACCOUNT="${MY_ACCOUNT%\\n}"               # get rid of return
        MY_ACCOUNT=`echo $MY_ACCOUNT | sed 's/\s//g'` # get rid of spaces
        if [[ $MY_ACCOUNT =~ ^$ ]]; then
            echo "Please "
            echo "       remove idev_project line${MID} from $HOME/.idevrc"
            echo "and execute idev again."
            exit 1
        fi
           check_project=no
        if [[ $MY_ACCOUNT =~ use_default ]]; then
           IDEV_ACCOUNT=" "
           res_list[${pr_no_A}]=`  printf "$res_format3"  "Project"         "$MY_ACCOUNT"         "SLURM default"`
        else
           IDEV_ACCOUNT="-A  $MY_ACCOUNT"
           res_list[${pr_no_A}]=`  printf "$res_format3"  "Project"         "$MY_ACCOUNT"         "$S_idevrc"`
        fi
     fi

#                                                 Get time default
     grep -Pq "idev_time${MID}\s" $HOME/.idevrc
     if [[ $? == 0 ]]; then
        MY_TIME=`grep -P "idev_time${MID}\s" $HOME/.idevrc | sed "s/idev_time${MID}//"`
        MY_TIME="${MY_TIME%\\n}"               # get rid of return
        MY_TIME=`echo $MY_TIME | sed 's/\s//g'` # get rid of spaces
          if [[ $MY_TIME =~ ":" ]]; then
                   MY_H_RT="h_rt=$MY_TIME"
                   MY_hhmmss_TIME="$MY_TIME"
                   regex='0*([[:digit:]]+)[:::]0*([[:digit:]]+)[:::]0*([[:digit:]]+)'
                   if [[ "$MY_H_RT" =~ $regex ]]; then
                     secs=$((${BASH_REMATCH[1]}*3600+${BASH_REMATCH[2]}*60+${BASH_REMATCH[3]}))
                   else
                     echo " -> ERROR:  default time syntax: time <#>."
                     echo "            Value found: \"$MY_TIME\""
                     exit
                   fi
                   MY_MINUTES=$(( secs / 60 ))
                   job_sleep=$secs
                   res_list[${pr_no_tm}]=` printf "$res_format3"  "Time (hh:mm:ss)" "$MY_TIME"            "$S_idevrc"` 
          else
                   MY_MINUTES=$MY_TIME
                            MY_H_RT="h_rt=00:${MY_MINUTES}:00 "  #SLURM accepts more than 2 digits in this field.
                          MY_hhmmss_TIME="00:${MY_MINUTES}:00 "  #SLURM accepts more than 2 digits in this field.
                   job_sleep=$(( $MY_MINUTES * 60 ))
                   res_list[${pr_no_tm}]=` printf "$res_format3"  "Time (min)" "$MY_TIME"            "$S_idevrc"` 
          fi
     else
           res_list[${pr_no_tm}]=` printf "$res_format3"  "Time (minutes)"  "$MY_MINUTES"         "$S_idev_default"` 

     fi

     grep -Pq "idev_queue${MID}\s" $HOME/.idevrc
     if [[ $? == 0 ]]; then
        MY_QUEUE=`grep -P "idev_queue${MID}\s" $HOME/.idevrc | sed "s/idev_queue${MID}//"`
        MY_QUEUE="${MY_QUEUE%\\n}"                # get rid of return
        MY_QUEUE=`echo $MY_QUEUE | sed 's/\s//g'` # get rid of spaces
        [[ $MY_QUEUE =~ gpu    ]] && queue_arch=gpu
        [[ $MY_QUEUE =~ vis    ]] && queue_arch=gpu
        [[ $MY_QUEUE =~ serial ]] && queue_arch=serial
        res_list[${pr_no_que}]=`printf "$res_format3"  "Queue"           "$MY_QUEUE"           "$S_idevrc"`
     else
        if [[ $MY_QUEUE == normal && $MID == _knl ]]; then
           caution="If long wait, use development queue." 
           res_list[${pr_no_que}]=`printf "$res_format4"  "Queue"           "$MY_QUEUE"           "$S_idev_default"  "$caution" `  
        else
           res_list[${pr_no_que}]=`printf "$res_format3"  "Queue"           "$MY_QUEUE"           "$S_idev_default"`
        fi
     fi


     grep -Pq "idev_rm_env${MID}\s" $HOME/.idevrc
     if [[ $? == 0 ]]; then
        IDEV_RM_ENV=`grep -P "idev_rm_env${MID}\s" $HOME/.idevrc | sed "s/idev_rm_env${MID}\s//"`
        IDEV_RM_ENV="${IDEV_RM_ENV%\\n}"               # get rid of return
        IDEV_RM_ENV=`echo "$IDEV_RM_ENV" | sed 's/^ *//g' | sed 's/ *$//g'` # get rid of spaces
###FIX to accommodate string size of variables 
         res_list[${pr_no_rv}]=` printf "$res_format3"  "Removed env vars" "$IDEV_RM_ENV"       "$S_idevrc"`
        export IDEV_RM_ENV
     fi

     grep -Pq "idev_email_address${MID}\s" $HOME/.idevrc
     if [[ $? == 0 ]]; then
        MY_ADDRESS=`grep -P "idev_email_address${MID}\s" $HOME/.idevrc | sed "s/idev_email_address${MID}\s//"`
        MY_ADDRESS="${MY_ADDRESS%\\n}"               # get rid of return
        MY_ADDRESS=`echo "$MY_ADDRESS" | sed 's/^ *//g' | sed 's/ *$//g'` # get rid of spaces
        export MY_ADDRESS
     fi

     MY_SSH_ARGS="-A"
     grep -Pq "idev_ssh_args${MID}\s" $HOME/.idevrc
     if [[ $? == 0 ]]; then
        RC_SSH_ARGS=`grep -P "idev_ssh_args${MID}\s" $HOME/.idevrc | sed "s/idev_ssh_args${MID}\s//"`
        RC_SSH_ARGS="${RC_SSH_ARGS%\\n}"               # get rid of return
     fi

     if [[ -z ${IDEV_SSH_ARGS+x} ]]; then   #unset
        MY_SSH_ARGS="-A"
        [[ ! -z ${RC_SSH_ARGS+x} ]] && MY_SSH_ARGS=$RC_SSH_ARGS
        export MY_SSH_ARGS
     else
        if [[ ${IDEV_SSH_ARGS} =~ default ]]; then   #set
           MY_SSH_ARGS=${IDEV_SSH_ARGS#default}; #Remove prefix
           cp -p $HOME/.idevrc  $HOME/.idevrc.$$
           if [[ -z ${RC_SSH_ARGS+x} ]]; then    #set
              echo "idev_ssh_args${MID} $MY_SSH_ARGS" >> $HOME/.idevrc
           else
              sed -i "s/^idev_ssh_args${MID}.*/idev_ssh_args${MID} $MY_SSH_ARGS/"       .idevrc
           fi 

        else 
           MY_SSH_ARGS=$IDEV_SSH_ARGS
        fi
        export MY_SSH_ARGS
     fi

                        # Look for ALL idev_tpn_<queue name>_<this machine> pairs
                        # Create array.  If size not zero and successful grep,  change idevrc_tpn to "set"
     if [[ x${MID} = x ]]; then
        Q_TpN_array=( `grep  -P 'idev_tpn_[^_]*\s' $HOME/.idevrc` )         # has no SYS suffix
        grep_status=$?
     else
       #Q_TpN_array=( `grep  -P "idev_tpn_[^_]*_${MID}\s" $HOME/.idevrc` )  # has a SYS suffix
        Q_TpN_array=( `grep  -P "idev_tpn_[^_]*${MID}\s" $HOME/.idevrc` )  # has a SYS suffix
        grep_status=$?
     fi
     #if [[ $grep_status == 0 &&  ${#Q_TpN_array[*]} != 0 ]]; then  # then possibly if set determined below
     # idevrc_tpn=unset 
     
  fi

############################################end  .idevrc options

# Determine my present working shell
 idev_ppid=`ps -l |  awk '{if ($4 == '$$'        ) print $5 }'`
 idev_cmd=` ps -l |  awk '{if ($4 == '$idev_ppid') print $14}'`

 if [[ $idev_cmd =~ (tcsh|csh) ]] ; then
    idev_pwshell=tcsh
 else
    idev_pwshell=bash
 fi


# Determine my LOGIN shell
 my_gecos=`grep $USER /etc/passwd`
 if [[ $my_gecos =~ (tcsh$|csh$) ]] ; then
    idev_login_shell=tcsh
    idev_pwd_cmd='setenv IDEV_PWD `pwd`'
    idev_env_set=setenv
    idev_env_equal=" "

                   # rm PERL5LIB for idev env_replication, but put in /tmp/env
    idev_rm_perl5="       
       setenv idev_has_user_PERL5LIB no
       if (\$?PERL5LIB && { eval 'test ! -z \$PERL5LIB' } ) then
          setenv idev_user_PERL5LIB \${PERL5LIB} && setenv idev_has_user_PERL5LIB yes
          unsetenv PERL5LIB
       endif
    "
 else
    idev_login_shell=bash
    idev_pwd_cmd='export IDEV_PWD=`pwd`'
    idev_env_set=export
    idev_env_equal="="
                   # rm PERL5LIB for idev env_replication, but put in /tmp/env
    idev_rm_perl5='        
       export idev_has_user_PERL5LIB=no;
       if [[ ! -z "$PERL5LIB" ]]; then
          export     idev_user_PERL5LIB=$PERL5LIB
          export idev_has_user_PERL5LIB=yes
          unset PERL5LIB
       fi
    '
 fi

if [[ $idev_pwshell -ne $idev_login_shell ]]; then
   echo " Warning:  Your present working shell is $idev_pwshell."
   echo "           Your login           shell is $idev_login_shell."
   echo "           Idev will place you in your login shell on the master node."
fi


MY_RESOURCE=""
CREATE_NODE_LIST_CMD=""

#OPERATION  Set batch system parameters.

monitor_sleep=4
sleep_after_run_factor=4
job_sleep=$(( MY_MINUTES * 60 ))


############################################beg system defaults

TOT_TASK_msg=""
Q="-p"
MY_PROJECT=""  #CHECK
export IDEV_QDEL=scancel
BATCH_SYS=SLURM
sleep_after_run=7

case $MY_SYS in

   frontera)
             ;;

     hikari)
             ;;

   maverick2)
             ;;

   longhorn)
             ;;

        ls6)
             ;;

   stampede)
             DOTHIS="" #execute cp cmd in job script-- old z85_ script needs this
             ;;

   stampede2)
             DOTHIS="" #execute cp cmd in job script-- old z85_ script needs this
             ;;

   wrangler)
             ;;

        knl)
             sleep_after_run=5

             TOT_TASK_msg="       (e.g. use -N 1 --tasks-per-node 68 for 1 MPI proc/core)"
             export IDEV_LOGIN_SOURCING=USER  #remove for production version
             ;;


          *) echo " Don't know about this system ($MY_SYS)"
             exit 1
             ;;
esac

############################################end system defaults

echo -e "\n NOTE: \"->\" are idev statements. \"-->\" are TACC/SLURM filter statements.\n"


############################################beg idev options
do_exit=no
# check_project=yes     ##9/8/2021
cmd_args=$@

#cmd line arguments -- they override everything
                          ARG_IS_DASH=no
                      HAS_double_dash=no

[[ $@ =~ ' -- ' ]] && HAS_double_dash=yes   #Need to know if command line has a --
                                            #Getopt puts one at end if user doesn't.

regex="^-"   #used for detecting an option/argument that begins with a "-".

OPT_ERR=0

OPTS=`getopt -a -o A:m:n:N:r:e:t:p:hvER --long help,version,uninstall,rank0,queues,pselect,qselect,tpn:,tasks-per-node:,ntasks-per-node:, -n ' -> ERROR idev' -- "$@"`

if [ $? != 0 ] ; then 
  echo " -> Failed parsing options." 
  if [[ $HAS_double_dash == yes ]]; then
    echo " -> ber that all slurm option must be placed after all idev options and a -- (e.g. idev -N1 -- <slurm options>)" >&2 
    echo " -> Any options appearing after \"--\" are handed directly to slurm (e.g. idev -N1 -- <pass-through slurm options>)" >&2 
    echo " -> These are not checked by idev and should not override idev options." >&2 
  fi
  exit 1 
fi

[[ $IDEV_DEBUG == ON ]] && echo " -> DEBUG: Options getopt found: $OPTS"
eval set -- "$OPTS"

while true; do
  case "$1" in
    -h|--help)
       echo ""
       echo "Usage:  idev [OPTIONS]"
       echo " "
       echo "idev creates an interactive session on a compute node"
       echo "for executing serial, openmp-parallel, or mpi-parallel"
       echo "code as you would in a batch job."
       echo "Supported systems: $TACC_SUPPORTED_SYSTEM."
       echo ""
       echo "Idev uses a single node by default and charges the project in \$HOME/.idevrc."
       echo "Options can be in any order."
       echo ""
#      echo "On TACC systems:"
#      echo "Compute nodes in the developement queue allow MPI compilation and execution."
#      echo " <<On Stampede MPI mpicc/mpif90 compilers do not work* on compute nodes in other queues."
#      echo "                            * missing license file or libraries when compiling."
#      echo "  Use a login node window for MPI compiling, and an idev window for running."
#      echo "  Other TACC systems allow MPI compilation and execution in any queue.>>"
#      echo " "
       echo "OPTIONS:"
       echo " OPTION  ARGUMENTS          DESCRIPTION"
       echo ""
       echo "  -A     account_name       sets account name (default: -A $MY_ACCOUNT)"
       echo "  -m     minutes            sets time in minutes (default: $MY_MINUTES)"
       echo "  -n     total_tasks        Total number of tasks"
       echo "  -N     nodes              Number of nodes"
       echo "  -tpn   tpn                Tasks per node"
       echo "                            -tasks-per-node|--tasks-per-node   tpn  (-tpn alternate)"
       echo "                            -ntasks-per-node|--ntasks-per-node tpn  (-tpn alternate)"
       echo "  $Q     queue_name         sets queue to named queue (default: $Q $MY_QUEUE)"
       echo "  -R                        Finds a reservation for the user."
       echo "  -r     reservation_name   requests use of a specific reservation"
       echo "  -r     none               idev always automatically looks for reserations"
       echo "                            and asks you to use an ACTIVE res. none==don't look/ask."
       echo "                            (use    scontrol show reserations to see reservation details)"
       echo "  -E                        notify when job begins"
       echo "                            uses email address idev_email_address${MID} in \$HOME/.idevrc"
       echo "  -e     email_address      notify when job begins, cmd line email address required."
       echo "  -t     hh:mm:ss           sets time to hh:mm:ss (default: 00:${MY_MINUTES}:00, 30 min.)"
       echo ""
       echo "  -queues                   lists queues for the system"
       echo "  -pselect                  presents slurm queue to select from"
       echo "  -qselect                  presents slurm queue to select from"
       echo "  -- <other SLURM options>  MUST occur after ALL idev options (above and below)"

       echo ""
       echo "  -h, --help,               displays (this) help message"
       echo "  -v, --version             output version information and exit"
       echo ""
       echo "  All non-single character options can start with \'-\' or \'--\'. "
       echo ""
       echo "  Syntax and Examples:"
       echo "       Syn: idev     (defaults: 1 node, 16 tasks, $MY_MINUTES min., default account.)"
       echo "       Syn: idev  [--help | -v | -uninstall] "
       echo "       Syn: idev  [-p queue]  [-m min.] [-t time ]  [-A acct] \ "
       echo "                  [-n tasks]  [-N nodes  -n tasks]  "
       echo ""
       echo "       ex1: idev"
       echo "       ex2: idev --help"
       echo "       ex3: idev -p development -m 90       -A AB-ccviss"
       echo "       ex4: idev -p normal      -t 00:90:00 -A TG-STA123 -N 2 -n 16 "
       echo "       ex5: idev -p normal -- -w c560-102 -v"
       echo ""

       echo "Idev ssh's to compute nodes with the -Y option to allow X forwarding for (for GUI displays)."
       echo ""

       echo "Insert  \"idev_time${MID} TIME\",  \"idev_queue${MID} QUEUE\" or  \"idev_project${MID} PROJECT\" "
       echo "        without quotes, one item per line in ~/.idevrc to set your own default "
       echo "        time, queue and/or project.  (Substitute values for TIME (integer minutes"
       echo "        or HH:MM:SS time) QUEUE and PROJECT.)"
       echo "        E.g.  idev_time${MID} 60"
       echo "              idev_queue${MID} normal" 
       echo ""

       echo "Insert  \"idev_email_address${MID} MYADDRESS\", without quotes in ~/.idevrc so you can"
       echo "         use -e without an address option on the idev command line."
       echo "         Substitue your email address for MYADDRESS."
       echo ""

       echo "Insert  \"idev_rm_env${MID} VAR_LIST\" "
       echo "        in ~/.idevrc, where VAR_LIST is a space separated list of environment"
       echo "        variables not to be replicated from the job environment initialized by idev.  "
       echo "        Note: all SSH_xx variables are removed by default so that all interactive "
       echo "        ssh terminal sessions have their correct SSH_xx values for a new session."
       echo ""

       echo "Insert  \"idev_ssh_args${MID} ARGS\" "
       echo "        in ~/.idevrc, where ARGS is a space separated list of ssh arguments for."
       echo "        the terminal window. -Y and -o \"StrictHostKeyChecking no\" are hard coded"
       echo "        arguments.  -A is now the default (For large-scale MV2 MPI executions on"
       echo "        Frontera) -A may need to be replaced by setting IDEV_SSH_ARGS."
       echo "        If the argument value is \"default <anything>\" this becomes the new user"
       echo "        default and will appear as the value for idev_ssh_args${MID} in .idevrc"

       do_exit="information_only"; OPT_ERR=0
       shift;;
    -v|--version)
      echo "Version          : $IDEV_VER"
      do_exit="information_only"; OPT_ERR=0
      shift;;
    --uninstall)
      insert_option=uninstall
      shift;;
    -n)
      [[ $2 =~ $regex ]] && ARG_IS_DASH=yes ED1=$1 ED2=$2 && break  # Forgotten Argument
      opt_tasks=set
      opt_total_tasks=set
      opt_TASK_count=$(( $opt_TASK_count + 1 ))
      shift; MY_TOTAL_TASKS=$1;  total_tasks_set=yes
      res_list[${pr_no_n}]=`  printf "$res_format3"  "Total tasks"     "$MY_TOTAL_TASKS"     "$S_cmd_line -n"`
      shift;;
    --tasks-per-node|--ntasks-per-node)
      [[ $2 =~ $regex ]] && ARG_IS_DASH=yes ED1=$1 ED2=$2 && break  # Forgotten Argument
      opt_tasks=set
      hold=$1
                          #only count -tpn or --tasks-per-node once
      [[ $opt_tasks_per_node != set ]] && opt_TASK_count=$(( $opt_TASK_count + 1 ))
      shift; MY_TASKS_PER_NODE=$1;  opt_tasks_per_node=set
      res_list[${pr_no_tpn}]=`printf "$res_format3l" "Tasks per Node" "$MY_TASKS_PER_NODE"  "$S_cmd_line --tasks-per-node"`
      [[ x$hold == x--tasks-per-node   ]] && tpn_type="--tasks-per-node"
      [[ x$hold == x--ntasks-per-node  ]] && tpn_type="--ntasks-per-node"
      shift;;
 --tpn)
      [[ $2 =~ $regex ]] && ARG_IS_DASH=yes ED1=$1 ED2=$2 && break  # Forgotten Argument
      opt_tasks=set
                          #only count -tpn or --tasks-per-node once
      [[ $opt_tasks_per_node != set ]] && opt_TASK_count=$(( $opt_TASK_count + 1 ))
      shift; MY_TASKS_PER_NODE=$1;  opt_tasks_per_node=set
      res_list[${pr_no_tpn}]=`printf "$res_format3l" "Tasks per Node" "$MY_TASKS_PER_NODE"  "$S_cmd_line --tpn"`
      tpn_type="-tpn"
      shift;;
    -N)
      [[ $2 =~ $regex ]] && ARG_IS_DASH=yes ED1=$1 ED2=$2 && break  # Forgotten Argument
      opt_N=set
      #opt_NODE_count=$(( $opt_NODE_count + 1 ))
      shift; MY_NODES=$1; opt_nodes=set;
      opt_NODE_count=$1
      res_list[${pr_no_N}]=`  printf "$res_format3"  "Nodes"           "$MY_NODES"           "$S_cmd_line -N"`
      shift;;
    -p)
      [[ $2 =~ $regex ]] && ARG_IS_DASH=yes ED1=$1 ED2=$2 && break  # Forgotten Argument
      shift; MY_QUEUE=$1
      CMDLINE_QUEUE=$MY_QUEUE
      queue_from=cmdline
      res_list[${pr_no_que}]=`printf "$res_format3"  "Queue"           "$MY_QUEUE"           "$S_cmd_line -p"`
      shift;;
    -q)
      [[ $2 =~ $regex ]] && ARG_IS_DASH=yes ED1=$1 ED2=$2 && break  # Forgotten Argument
      shift; MY_QUEUE=$1
      CMDLINE_QUEUE=$MY_QUEUE
      queue_from=cmdline
      res_list[${pr_no_que}]=`printf "$res_format3"  "Queue"           "$MY_QUEUE"           "$S_cmd_line -q"` 
      shift;;
    --queues)
      list_node_queue=yes
      shift;;
    --qselect|--pselect)
      qselect=yes
      shift;;    
    -A)
      [[ $2 =~ $regex ]] && ARG_IS_DASH=yes ED1=$1 ED2=$2 && break  # Forgotten Argument
      shift; IDEV_ACCOUNT="-A  $1"
      account=$1
      check_project=no
      acct_from=cmdline
      res_list[${pr_no_A}]=`  printf "$res_format3"  "Project"         "$account"         "$S_cmd_line -A"`
      shift;;
    -t)
      [[ $2 =~ $regex ]] && ARG_IS_DASH=yes ED1=$1 ED2=$2 && break  # Forgotten Argument
      shift; MY_H_RT="h_rt=$1"
      regex='0*([[:digit:]]+)[:::]0*([[:digit:]]+)[:::]0*([[:digit:]]+)'
      if [[ "$MY_H_RT" =~ $regex ]]; then
          secs=$((${BASH_REMATCH[1]}*3600+${BASH_REMATCH[2]}*60+${BASH_REMATCH[3]}))
      else
        echo "-> ERROR:  h_rt (syntax hr:min:sec) requires value for hr, min and sec entry."
        echo "           Value found: \"$MY_H_RT\""
        exit
      fi
      job_sleep=$secs
      MY_hhmmss_TIME=$1
      res_list[${pr_no_tm}]=` printf "$res_format3"  "Time (hh:mm:ss)" "$MY_hhmmss_TIME"            "$S_cmd_line -t"`
      shift;;
    -m)
      [[ $2 =~ $regex ]] && ARG_IS_DASH=yes ED1=$1 ED2=$2 && break  # Forgotten Argument
      shift; MY_MINUTES=$1
             MY_H_RT="h_rt=00:${MY_MINUTES}:00 "  #SLURM accept more than 2 digits in this field.
             MY_hhmmss_TIME="00:${MY_MINUTES}:00 "  #SLURM accept more than 2 digits in this field.
      job_sleep=$(( $MY_MINUTES * 60 ))
      res_list[${pr_no_tm}]=` printf "$res_format3"  "Time (minutes)"  "$MY_MINUTES"         "$S_cmd_line -m"`
      shift;;
    --rank0)
      echo -e "\n **The -rank0 option is not allowed on $MY_SYS."
      echo -e "     It is not a valid $BATCH_SYS option."
      echo -e "     See options, execute: idev -help"
      do_exit=yes; OPT_ERR=1
      shift;;
    -R)
      # Find reservation for user
      RESERVATION_CONTROL="FIND_IT"
      echo " -> Reservation      : Will try to find a reservation set for you."
      shift;;
    -r)
      [[ $2 =~ $regex ]] && ARG_IS_DASH=yes ED1=$1 ED2=$2 && break  # Forgotten Argument
      # Found reservation request with name
      shift
      if [[ $1 =~ none ]]; then
          RESERVATION_CONTROL="NONE"
          MY_RESERVATION=""
          echo " -> Reservation      : $1  -- disregard any reservation"
      else
        RESERVATION_CONTROL="USER_SET"
        RESERVATION_NAME=$1
        MY_RESERVATION="--reservation=$1"
        echo " -> Reservation      : $1  -- will attempt to use this reservation"
        echo " ->                        -- use -A option to override Account specified in reservation."
        MY_RESERVATION="#SBATCH $MY_RESERVATION"
      fi
      shift;;
    -E)
      if [[ $MY_ADDRESS == "none" ]] ; then
          echo " -> Cmd line: $0 $cmd_args"
          echo " -> ERROR: -E option requires email address found in \$HOME/.idevrc"
          echo "           add new line of form:  idev_email_address${MID} <me>@<domain.x>"
          do_exit=yes; OPT_ERR=1
          break # stop parsing
      fi
      if ! [[ $MY_ADDRESS =~ @ ]]; then
          echo -e "\n -> ERROR: ** Detected improper email address -- no @ found."
          echo -e "                  Found email address $MY_ADDRESS."
          echo -e "                  Check value of idev_email_address in ~/.idevrc."
          do_exit=yes; OPT_ERR=1
          break # stop parsing
      fi
      res_format=$res_format3e
      nchars=${#MY_ADDRESS}
      [[ $nchars -gt 12 ]] && res_format=' -> %-17.17s: %-'${nchars}.${nchars}'s  (%-20.20s)'
     #res_list[${pr_no_e}]=`  printf "$res_format"   "Job begin email" "$MY_ADDRESS"   "cmdln: -e <address>"`
      res_list[${pr_no_e}]=`  printf "$res_format"   "Job begin email" "$MY_ADDRESS"   "cmdln: -E; ~/.idevrc addr"`
      
      using_rc_email_address=yes

      MY_EMAIL="#SBATCH --mail-type=BEGIN --mail-user=$MY_ADDRESS"
      shift;;
    -e)
      [[ $2 =~ $regex ]] && ARG_IS_DASH=yes ED1=$1 ED2=$2 && break  # Forgotten Argument
      shift  
      #Check for email address
      if [[ "$1" =~ @ ]]; then
          MY_ADDRESS="$1"
          using_rc_email_address=no

          res_format=$res_format3e
          nchars=${#MY_ADDRESS}
          [[ $nchars -gt 12 ]] && res_format=' -> %-17.17s: %-'${nchars}.${nchars}'s  (%-20.20s)'
          res_list[${pr_no_e}]=`  printf "$res_format"   "Job begin email" "$MY_ADDRESS"   "cmdln: -e <address>"`

      else
        #line does not have email address
        echo " ->Cmd line: $0 $cmd_args"
        echo -e "\n -> ERROR: ** Detected improper email address for -e option -- no @ found."
        echo    "                Fix email address."
        echo    ""
        echo "                   Alternate solution: Use -E option and include address in \$HOME/.idevrc."
        echo "                   (* add new line of form:  idev_email_address${MID} <me>@<domain.x> )"
        do_exit=yes; OPT_ERR=1
        break # stop parsing
      fi

      using_rc_email_address=yes
      MY_EMAIL="#SBATCH --mail-type=BEGIN --mail-user=$MY_ADDRESS"
      shift;;

#  -- ) 
    --) 
      # getopt puts a "--" at end if the user does not (set IDEV_DEBUG to see this).
      # Process only if user provided a " -- " in command line (and ignore if nothing after user --).
      shift
        if [[ x$1 != x ]] && [[ $HAS_double_dash == yes ]]; then
          slurm_options="$*"
          IDEV_SLURM_ARGS="#SBATCH $slurm_options"
          nchars=${#slurm_options}
          res_format=$res_format3
          #[[ $nchars -gt 40 ]] && res_format=' -> %-17.17s: %-'${nchars}.${nchars}'s  (%-20.20s)'
          #res_list[${pr_no_sb}]=` printf "$res_format3"  "SLURM options" "$slurm_options"       "$S_cmd_line --"`
          [[ $nchars -gt 15 ]] && res_format=' -> %-17.17s: %-'${nchars}.${nchars}'s  (%-20.20s)'
          res_list[${pr_no_sb}]=` printf "$res_format"  "SLURM options" "$slurm_options"       "$S_cmd_line --"`
        fi
      break ;;
  #                THIS IS NOT NEEDED singe "-- )" finishes everything up.
  # * ) 
  #   echo "NOW DO I GET HERE****************************************************************************************"
  #   break ;;
  esac
done

if [[ $ARG_IS_DASH == yes ]]; then
  echo " -> ERROR: Failed parsing for these two items on command line: $ED1 $ED2."
  echo " ->        The $ED1 requires an valid argument. Found $ED2, which is not valid."
# echo " -> -- marks the beginning of explicit slurm options (as in: idev -m 60 -- <slurm options>)."
  exit
fi


############################################end idev options
#
#   May need to exit here for help, version, unknown option, or option error
#   (Exit before asking questions about account, queue, etc. defaults.)
#
#------------------------------------------------------------------------------
[[ $do_exit == "information_only" ]] && exit $OPT_ERR
[[ $do_exit == "yes" ]] && exit $OPT_ERR
#------------------------------------------------------------------------------
#

############################################beg queue select
###SELECT QUEUE vvv

if [[ $qselect == yes ]]; then
 # Get list of queues -- this should be done wo a file

  sinfo -h --format="%.15R" >  $HOME/.idev${MID}_sinfo

  declare -a list
  declare -a node_queue

  # Load file into array.
  let i=0
  if [[ $list_node_queue == "yes" ]]; then
     echo ""
     echo "     Queue Name "
     echo ""
  fi

  while IFS=$'\n' read -r line; do
      list[i]="${line}"
      node_queue[i]=`echo "${line}" | awk '{print $1 }'`

      if [[ ${node_queue[$i]} ==  $MY_QUEUE ]]; then
         default_mac_no=$(($i+1))
      fi

      if [[ $list_node_queue == "yes" ]]; then
         echo  "     ${node_queue[i]} "
      fi
      ((++i))
  done < $HOME/.idev${MID}_sinfo
  rm -rf $HOME/.idev${MID}_sinfo

  [[ $list_node_queue == "yes" ]] && exit

  let i=0
  while (( ${#node_name[@]} > i )); do
     if [[ ${node_name[i]} == $MY_QUEUE ]]; then
        MY_QUEUE=${node_queue[i]}
     fi
     ((i++))
  done

  #ACTUAL QUEUE SELECTION
# if [[ $qselect == yes ]]; then
       echo "Please select the NUMBER of the queue you want to use.\n";

       count=1;
       for i in "${node_queue[@]}"
       do
          if [[ $i == $MY_QUEUE ]]; then
             echo "   $count $i  (default)"
          else
             echo "   $count $i "
          fi
          count=$(( $count + 1 ))
       done

       echo "Please type the NUMBER(default=$default_mac_no) and hit return: ";
       read  my_queue
       if [[ "$my_queue" == "" ]]; then my_queue=$default_mac_no; fi

       if ! [[ $my_queue =~ ^[0-9]+$  &&  (($my_queue -lt $count)) ]]; then
         echo " That was not a valid response.  You typed $my_queue. Try again."
         exit 1
       fi

       MY_QUEUE=${node_queue[ $(($my_queue-1)) ]}
       echo " -> $MY_QUEUE is the queue you selected."
fi
############################################end queue select
###--vDIR and RESERVATION PROCESSING (from ###MOVED DIR and RESERVATION... (from 1399)

# Make sure there is a .slurm directory:(
if [ ! -d $HOME/.slurm ]; then
   mkdir  $HOME/.slurm
   echo "Created          : \$HOME/.slurm"
fi


  DIR=`dirname $0`       #Need directory where idev & utils are
  [ x$? != x0 ] && exit 1;

  idev_dir=$DIR         #Need full path for PATH in login scripts
  [[ ! $idev_dir =~ ^/ ]] && idev_dir=$PWD/$idev_dir

############################################beg  RESERVATION

# Values of RESERVATION_CONTROL
# -r      --> FIND_IT
# -r none --> NONE
# -r xyz  --> USER_SET
#         --> NO_OPTION
#   tot tot_active  status         name queue
#    1   0/1        act/nonactive               1 doit, 0 advise
#    2+  1          ---                         doit 1 active
#    3+  0,2...     ---                         Advise

RESERVATION_NAME_FOUND=no
  if [[ $RESERVATION_CONTROL == NONE ]]; then
     # do nothing-- If the user set it, good luck.
     echo doing_nothing>/dev/null
  else

    res_q_warn=" -> ** WARNING \"-p $MY_QUEUE\" option will be ignored if you accept this reservation.\n"
    res_q_warn+=" ->             Reservation uses queue of reserved nodes.\n"
    res_q_warn+=" ->             Respond no if you want to use the $MY_QUEUE queue.\n"

    res_q_repl=" -> ** WARNING \"-p $MY_QUEUE\" option ignored using $RESERVATION_QUEUE of reservation.\n"

    declare -a active_res_names
    declare -a active_res_queues
    declare -a active_res_accts
    declare -a all_res_names
    declare -a all_res_queues
    declare -a all_res_status
    declare -a all_res_accts

    reservation_string=`$DIR/idev_utils get_reservation $USER`;
    reservation_array=( $reservation_string )
    res_totl=${reservation_array[0]}
    res_actv=${reservation_array[1]}
    res_stat=${reservation_array[2]}
    res_name=${reservation_array[3]}
    res_queue=${reservation_array[4]}
    res_acct=${reservation_array[5]}
    #                       (If we see 1 reservation all is done.)
    #                       Get ACTIVE reservation  information here.
    #                       (This is ugly/simple. Find ACTIVE/INACTIVE & assume values are stat,name,queue,acct
   #if [[ $res_totl -ge 2 && $res_actv -le 1 ]]; then
    if [[ $res_totl -ge 2 ]]; then
       for((i=0;i<${#reservation_array[@]};i++))
       do
   #                       Find 1 ACTIVE reservation.
   #                       For res_actv=0, nothing changes since ACTIVE not found.
   #                       We avoid the case for 2 or more ACTIVE reservations (later).
           #echo "RES_NAME $i ${reservation_array[$i]}"
           if [[ ${reservation_array[$i]} == ACTIVE ]]; then
             res_stat=${reservation_array[$i]}
             res_name=${reservation_array[  (($i+1)) ]}
             res_queue=${reservation_array[ (($i+2)) ]}
             res_acct=${reservation_array[   (($i+3)) ]}
             RESERVATION_USE=yes
             active_res_names=( "${active_res_names[@]}"  "$res_name")
             active_res_queues=("${active_res_queues[@]}" "$res_queue")
             active_res_accts=( "${active_res_accts[@]}"  "$res_acct")
           fi
           if [[ ${reservation_array[$i]} == ACTIVE ]] || [[ ${reservation_array[$i]} == INACTIVE ]] ; then
             all_res_stat=${reservation_array[$i]}
             all_res_name=${reservation_array[  (($i+1)) ]}
             all_res_queue=${reservation_array[ (($i+2)) ]}
             all_res_acct=${reservation_array[  (($i+3)) ]}
             all_res_status=("${all_res_status[@]}" "$all_res_stat")
             all_res_names=( "${all_res_names[@]}"  "$all_res_name")
             all_res_queues=("${all_res_queues[@]}" "$all_res_queue")
             all_res_accts=( "${all_res_accts[@]}"  "$all_res_acct")
           fi
       done
 
   #                       We validate what the user has set as a valid name.
   #                       This many not be an (the) active reservation!
       if [[ $RESERVATION_CONTROL == USER_SET ]]; then
       for((i=0;i<${#reservation_array[@]};i++))
       do
          if [[ ${reservation_array[$i]} == $RESERVATION_NAME ]]; then
             RESERVATION_NAME_FOUND=yes 
             RESERVATION_STATUS=${reservation_array[ (($i-1)) ]}
             RESERVATION_QUEUE=${reservation_array[  (($i+1)) ]}
             RESERVATION_ACCT=${reservation_array[   (($i+2)) ]}
             if [[ $RESERVATION_STATUS == INACTIVE && $res_actv == 1 ]]; then
                echo " -> NOTE: you have requested a INACTIVE reservation ($RESERVATION_NAME)."
                echo " -> NOTE: $res_name is your ACTIVE reservation." 

                if [[ $res_queue != '(null)' ]]; then
                   [[ $queue_from == cmdline ]] && echo -e -n "\033[1;36m$res_q_warn"; echo -e -n '\033[0m'
                fi
 
                echo " Do you really want to wait on a INACTIVE reservation?  (suggested answer: no)"
                echo -n " Enter y/n [default y]: "
                read -s -n 1 yorn
                echo ""
                if [[ $yorn != y && $yorn != n ]]; then  yorn=y; fi
  
                if [[ $yorn == y ]]; then
                   res_stat=INACTIVE
                   res_name=$RESERVATION_NAME
                   res_queue=$RESERVATION_QUEUE
                   res_acct=$RESERVATION_ACCT
                   RESERVATION_USE=yes
#
# warn about queue change:
#
                else 
                   echo " Adios.  Use \"scontrol show reservations\" to view reservations."
                   exit 1
                fi
             fi
          fi
       done
       fi
 
    fi #end if 2 or more reservation
 
    if [[ $res_totl -eq 0 ]]; then
       if [[ $RESERVATION_CONTROL == USER_SET ]]; then
         echo " -> No reservation named $RESERVATION_NAME for $USER was found."
         echo " -> Execute: \"scontrol show reservations\"  to see reservations."
         exit 1;
       fi
 
       if [[ $RESERVATION_CONTROL == FIND_IT ]]; then
         echo " -> No reservation for $USER was found."
         echo " -> Execute: \"scontrol show reservations\"  to see reservations."
         exit 1;
       fi
 
      # not here
      #if [[ $res_name != $RESERVATION_NAME ]]; then
      #echo " Please correct and try again."
      #else #slide on by
    fi
 
    if [[ $res_totl -eq 1 || (( $res_totl -ge 2 && $res_actv -eq 1 )) ]]; then
 
       if [[ $res_actv -eq 1  ]]; then
          RESERVATION_USE=yes
 
          # ACTIVE Reservation
             if [[ $RESERVATION_CONTROL == USER_SET ]]; then
                if [[ $res_name != $RESERVATION_NAME ]]; then
                   echo " -> ERROR:"
                   echo " -> idev reservation name (-r $RESERVATION_NAME) "
                   echo "    does not match slurm reservation name ($res_name)."
                   echo "    Aborting idev.  Execute: \"idev -R\" and idev will find the name for you."
                   echo "    Execute: \"scontrol show reservations\"  to see reservations."
                   exit 1;
                else           #good to go
                   RESERVATION_NAME=$res_name
                   MY_RESERVATION="#SBATCH --reservation=$res_name"
                   MY_QUEUE=$res_queue
                   RESERVATION_USE=yes

                   res_list[${pr_no_que}]=`printf "$res_format3"  "Queue"            "$MY_QUEUE"           "$S_reservation"`
                   res_list[${pr_no_res}]=`printf "$res_format3"  "Reservation name" "$res_name"           "$S_reservation ACTIVE"`

                   #use res acct (not overridden by cmd line -A)
                   if [[ $res_account != default ]] && [[ $res_account != '(null)' ]] &&  [[ $acct_from != cmdline ]]; then
                         MY_ACCOUNT=$res_acct
                         IDEV_ACCOUNT="-A $MY_ACCOUNT"
                         res_list[${pr_no_A}]=`  printf "$res_format3"  "Project"         "$MY_ACCOUNT"         "$S_reservation"`
                   fi
                fi #RES_NAME

             fi # USER_SET
 
            
             if [[ $RESERVATION_CONTROL == FIND_IT ]]; then
                   echo " -> Found a single ACTIVE reservation, $res_name, for you."
                   RESERVATION_NAME=$res_name
                   MY_RESERVATION="#SBATCH --reservation=$res_name"
                   MY_QUEUE=$res_queue
                   RESERVATION_USE=yes

                   res_list[${pr_no_que}]=`printf "$res_format3"  "Queue"            "$MY_QUEUE"           "$S_reservation"`
                   res_list[${pr_no_res}]=`printf "$res_format3"  "Reservation name" "$res_name"           "$S_reservation ACTIVE"`

                   #use res acct (not overridden by cmd line -A)
                   if [[ $res_account != default ]] && [[ $res_account != '(null)' ]] &&  [[ $acct_from != cmdline ]]; then
                      MY_ACCOUNT=$res_acct
                      IDEV_ACCOUNT="-A $MY_ACCOUNT"
                      res_list[${pr_no_A}]=`  printf "$res_format3"  "Project"         "$MY_ACCOUNT"         "$S_reservation"`
                   fi
             fi

             if [[ $RESERVATION_CONTROL == NO_OPTION ]]; then
                   echo " -> We found an ACTIVE reservation request for you, named $res_name."
                   echo "    Do you want to use it for your interactive session?"

                   if [[ $res_queue != '(null)' ]]; then
                      [[ $queue_from == cmdline ]] && echo -e -n "\033[1;36m$res_q_warn"; echo -e -n '\033[0m'
                   fi

                   echo -n " -> Enter y/n [default y]: "
                   read -s -n 1 yorn
                   echo ""
                   if [[ $yorn != y && $yorn != n ]]; then  yorn=y; fi
 
                   if [[ $yorn == y ]]; then 
                      RESERVATION_NAME=$res_name
                      MY_RESERVATION="#SBATCH --reservation=$res_name"
                      MY_QUEUE=$res_queue
                      RESERVATION_USE=yes

                      res_list[${pr_no_que}]=`printf "$res_format3"  "Queue"            "$MY_QUEUE"           "$S_reservation"`
                      res_list[${pr_no_res}]=`printf "$res_format3"  "Reservation name" "$res_name"           "$S_reservation ACTIVE"`

                      #use res acct (not overridden by cmd line -A)
                      if [[ $res_account != default ]] && [[ $res_account != '(null)' ]] &&  [[ $acct_from != cmdline ]]; then
                         MY_ACCOUNT=$res_acct
                         IDEV_ACCOUNT="-A $MY_ACCOUNT"
                         res_list[${pr_no_A}]=`  printf "$res_format3"  "Project"         "$MY_ACCOUNT"         "$S_reservation"`
                      fi


                   else  #Continue on as a non-reservation request.
                      echo " -> Continuing without using your reservation."
                      echo " -> Use \"scontrol show reservations\" to view your reservation(s)."
                      RESERVATION_USE=no 
                   fi

             fi #NO_OPTION
       else        ##INACTIVE RESERVATION
          
          if [[ $RESERVATION_CONTROL == USER_SET ]]; then

             echo ""
             echo "  ****** YOU HAVE AN INACTIVE RESERVATION ******"
             echo ""
             echo " -> Reservation      : --reservation=$res_name (INACTIVE)"
             echo " -> You explicitly requested this, so idev will proceed, as you wish."
             echo " -> Execute control-c if you get tired of waiting."
             echo " -> To see when the reservation begins, execute:  scontrol show reservations"

             RESERVATION_NAME=$res_name
             MY_RESERVATION="#SBATCH --reservation=$res_name"
             MY_QUEUE=$res_queue
             RESERVATION_USE=yes

             res_list[${pr_no_que}]=`printf "$res_format3"  "Queue"            "$MY_QUEUE"           "$S_reservation"`
             res_list[${pr_no_res}]=`printf "$res_format3"  "Reservation name" "$res_name"           "$S_reservation ACTIVE"`

             #use res acct (not overridden by cmd line -A)
             if [[ $res_account != default ]] && [[ $res_account != '(null)' ]] &&  [[ $acct_from != cmdline ]]; then
                MY_ACCOUNT=$res_acct
                IDEV_ACCOUNT="-A $MY_ACCOUNT"
                res_list[${pr_no_A}]=`  printf "$res_format3"  "Project"         "$MY_ACCOUNT"         "$S_reservation"`
             fi
          fi

          if [[ $RESERVATION_CONTROL == FIND_IT ]]; then
 
             echo ""
             echo " -> ****** WE fOUND an INACTIVE RESERVATION ($res_name) for you. ******"
             echo ""
             echo " Do you really want to wait on a INACTIVE reservation?  (suggested answer: no)"
             echo -n " Enter y/n [default y]: "
             read -s -n 1 yorn
             echo ""

             if [[ $yorn != y ]] && [[ $yorn != n ]]; then  yorn=y; fi
             if [[ $yorn == y ]]; then

                RESERVATION_NAME=$res_name
                MY_RESERVATION="#SBATCH --reservation=$res_name"
                MY_QUEUE=$res_queue
                RESERVATION_USE=yes
   
                res_list[${pr_no_que}]=`printf "$res_format3"  "Queue"            "$MY_QUEUE"           "$S_reservation"`
                res_list[${pr_no_res}]=`printf "$res_format3"  "Reservation name" "$res_name"           "$S_reservation ACTIVE"`
   
                if [[ $res_account != default ]] && [[ $acct_from != cmdline ]]; then  #use res acct (no override by cmd line -A) 
                    MY_ACCOUNT=$res_acct
                    IDEV_ACCOUNT="-A $MY_ACCOUNT"
                    res_list[${pr_no_A}]=`  printf "$res_format3"  "Project"         "$MY_ACCOUNT"         "$S_reservation"`
                fi
             else
                echo " Adios.  Use \"scontrol show reservations\" to view reservations."
                exit 1
             fi
#
          fi # FIND_IT
 
          if [[ $RESERVATION_CONTROL == NO_OPTION ]]; then
             echo " "
             echo " -> Just a Note: Your reservation $res_name is INACTIVE."
             echo " -> Use idev -R to use it when it becomes ACTIVE."
             echo " -> To see when it begins, execute:  scontrol show reservations"
             echo " "
             RESERVATION_USE=no
          fi
 
       fi #res_actv -eq 1
    fi #res_totl -eq 1

    if [[ $res_totl -ge 2 &&  $res_actv -ne 1 ]]; then

      # Don't process: $RESERVATION_CONTROL == NO_OPTION
 
       if [[ $RESERVATION_CONTROL == USER_SET ]]; then
          if [[ $RESERVATION_NAME_FOUND != yes ]]; then
             echo " ->idev didn't find a reservation ($RESERVATION_NAME)."
             echo " ->Execute: \"scontrol show reservations\"  to see reservations."
             exit 1
          else           #good to go
             if [[ $RESERVATION_STATUS == INACTIVE ]]; then

                echo " ->We found your reservation to be INACTIVE."
                echo "   idev will not run until it becomes ACTIVE."
                echo " ->Do you want to wait on it?  We suggest no."

                if [[ $res_queue != '(null)' ]]; then
                   [[ $queue_from == cmdline ]] && echo -e -n "\033[1;36m$res_q_warn"; echo -e -n '\033[0m'
                fi

                echo -n " Enter y/n [default y]: "
                read -s -n 1 yorn
                echo ""
                if [[ $yorn != y && $yorn != n ]]; then  yorn=y; fi
   
                if [[ $yorn == y ]]; then 
                   echo " ->Reservation      : --reservation=$RESERVATION_NAME (INACTIVE)"
                   MY_RESERVATION="#SBATCH --reservation=$RESERVATION_NAME"
                   MY_QUEUE=$RESERVATION_QUEUE
                   RESERVATION_USE=yes

                   res_list[${pr_no_que}]=`printf "$res_format3"  "Queue"            "$MY_QUEUE"           "$S_reservation"`
                   res_list[${pr_no_res}]=`printf "$res_format3"  "Reservation name" "$RESERVATION_NAME"           "$S_reservation INACTIVE"`

                   #use res acct (not overridden by cmd line -A)
                   if [[ $res_account != default ]] && [[ $res_account != '(null)' ]] &&  [[ $acct_from != cmdline ]]; then
                       MY_ACCOUNT=$res_acct
                       IDEV_ACCOUNT="-A $MY_ACCOUNT"
                       res_list[${pr_no_A}]=`  printf "$res_format3"  "Project"         "$MY_ACCOUNT"         "$S_reservation"`
                   fi

                else 
                   echo " ->Adios.  Use \"scontrol show reservations\" to view reservations."
                   exit 1
                fi
             else
         
                [[ $queue_from == cmdline ]]  && echo -e -n "\033[1;36m$res_q_sub"; echo -e -n '\033[0m'

                #But USER_SET assures us one particular reservation is requested.
                echo " ->Reservation      : --reservation=$RESERVATION_NAME (ACTIVE)"
                MY_RESERVATION="#SBATCH --reservation=$RESERVATION_NAME"
               MY_QUEUE=$RESERVATION_QUEUE
                RESERVATION_USE=yes

                res_list[${pr_no_que}]=`printf "$res_format3"  "Queue"            "$MY_QUEUE"           "$S_reservation"`
                res_list[${pr_no_res}]=`printf "$res_format3"  "Reservation name" "$RESERVATION_NAME"           "$S_reservation ACTIVE"`

                #use res acct (not overridden by cmd line -A)
                if [[ $res_account != default ]] && [[ $res_account != '(null)' ]] &&  [[ $acct_from != cmdline ]]; then
                   MY_ACCOUNT=$res_acct
                   IDEV_ACCOUNT="-A $MY_ACCOUNT"
                   res_list[${pr_no_A}]=`  printf "$res_format3"  "Project"         "$MY_ACCOUNT"         "$S_reservation"`
                fi

             fi #INACTIVE
          fi #RES_NAME_FOUND != yes
       fi #USER_SET
 
       if [[  $RESERVATION_CONTROL == FIND_IT ]]; then
          if [[ $res_actv -gt 1  ]]; then
             echo -e "\n -> You have $res_actv ACTIVE reservations."
             echo -e "    I'm at a loss as to which one idev should use."
             echo -e "    Please execute idev again with a reservation name with the -r <reservation_name> option."
             echo -e "    Reservations (names) are listed below. Use:  \"scontrol show reservations\" for details."

            #printf "      %-24s %-16s   %-10s\n" "Reservation"   "Associated Queue" "STATUS"
             printf "      %-24s %-16s   %-10s   %-20s\n" "Reservation"   "Associated Queue" "STATUS" "Project"
             for i in "${!all_res_names[@]}"; do
              #printf "      %-24s %-16s   %-10s\n" ${all_res_names[$i]}  ${all_res_queues[$i]} ${all_res_status[$i]}
               printf "      %-24s %-16s   %-10s  %-20s\n" ${all_res_names[$i]}  ${all_res_queues[$i]} ${all_res_status[$i]} ${all_res_accts[$i]}
             done
             echo     "      First known project of $USER is selected when reservation lists multiple projects."
             echo     "      Use -A option to charge a particular project. \"scontrol show res\" lists all projects."
             exit 1
          fi

          if [[ $res_actv -eq 0  ]]; then
             echo -e "\n -> You have NO ACTIVE reservations and $res_totl INACTIVE reservations."
             echo -e "    You can wait in idev on a reservation to become available (not suggested)."
             echo -e "    I'm at a loss as to which one should be used."
             echo -e "    If so, please execute idev again with the -r <reservation_name> option."
             echo -e "    Reservations (names) are listed below. Use:  \"scontrol show reservations\" for details."

            #printf "      %-24s %-16s   %-10s\n" "Reservation"   "Associated Queue" "STATUS"
             printf "      %-24s %-16s   %-10s   %-20s\n" "Reservation"   "Associated Queue" "STATUS" "Project"
             for i in "${!all_res_names[@]}"; do
              #printf "      %-24s %-16s   %-10s\n" ${all_res_names[$i]}  ${all_res_queues[$i]} ${all_res_status[$i]}
               printf "      %-24s %-16s   %-10s  %-20s\n" ${all_res_names[$i]}  ${all_res_queues[$i]} ${all_res_status[$i]} ${all_res_accts[$i]}
             done
             echo     "      First known project of $USER is selected when reservation lists multiple projects."
             echo     "      Use -A option to charge a particular project. \"scontrol show res\" lists all projects."
             exit 1
          fi
       fi

       if [[  $RESERVATION_CONTROL == NO_OPTION  ]]; then
          if [[ $res_actv -gt 1  ]]; then
             echo -e "\n -> NOTE: **** You have $res_actv ACTIVE reservations.                ****"
             echo -e "          **** Idev expects that you want to use one of them. ****"
             echo -e "               Select one from list below."
             echo -e "               or select the continue without using any reservation option."
             echo -e "               or select exit ( you can always type ^c to exit at any time). "
             echo -e ""

# Request selection here:
                       # Set up Reservation Selection
          
             echo " -> Select a reservation from one of the following ACTIVE Reservations:"

             printf "      %-24s %-16s   %-10s  %-20s\n" "Reservation"   "Associated Queue" "STATUS" "Project"
             for i in "${!all_res_names[@]}"; do
               printf "      %-24s %-16s   %-10s  %-20s\n" ${all_res_names[$i]}  ${all_res_queues[$i]} ${all_res_status[$i]} ${all_res_accts[$i]}
             done
             echo     "      First known project of $USER is selected when reservation lists multiple projects."
             echo     "      Use -A option to charge a particular project. \"scontrol show res\" lists all projects."
             echo     "      Only ACTIVE reservations are selectable. Use -r option to specify an INACTIVE reservation."

             echo ""
             echo " $IDEV_SYM  Advice: use \"-r none\" to eliminate reservation prompting."
             echo ""
          
             declare -a select_values
             select_values=("${active_res_names[@]}")
             select_values+=('I_do_not_want_to_use_any_of_my_ACTIVE_reservations_continue')  #2/7/18 allow opt out
             select_values+=('exit')
             select_type="Reservation"

             selected_no_default="none" # 2/7/18  Do not allow a default

             select_one                 # Have the user select a reservation

             unset select_values        #clean up
             res_name="$selected_value"

             if [[ ! $res_name =~ "I_do_not_want" ]]; then   # 2/7/18 if found "I_do_not_want_to", don't follow next reservation code
                                   # Find the queue for the selected active reservation

               for i in "${!active_res_names[@]}"; do
                 if [[ "${active_res_names[$i]}" = "${res_name}" ]]; then
                    res_queue="${active_res_queues[$i]}"
                    res_account="${active_res_accts[$i]}"
                    res_acct="${active_res_accts[$i]}"
                 fi
               done

               RESERVATION_NAME=$res_name
               MY_RESERVATION="#SBATCH --reservation=$res_name "
               MY_QUEUE=$res_queue
               RESERVATION_USE=yes
  
               res_list[${pr_no_que}]=`printf "$res_format3"  "Queue"            "$MY_QUEUE"           "$S_reservation"`
               res_list[${pr_no_res}]=`printf "$res_format3"  "Reservation name" "$res_name"           "$S_reservation ACTIVE"`

               #use res acct (not overridden by cmd line -A)
               if [[ $res_account != default ]] && [[ $res_account != '(null)' ]] &&  [[ $acct_from != cmdline ]]; then 
                  MY_ACCOUNT=$res_acct
                  IDEV_ACCOUNT="-A $MY_ACCOUNT"
                  res_list[${pr_no_A}]=`  printf "$res_format3"  "Project"         "$MY_ACCOUNT"         "$S_reservation"`
               fi
  
             fi #res_name != I_do_not_want
          else 

             echo -e "\n -> FYI: You have $res_totl INACTIVE reservations."
             echo -e " ->      Idev is not asking to use them because they are INACTIVE."
             echo -e " ->      If you want to wait on one of them, re-execute idev with the -r option."
             echo -e " ->      Execute \"scontrol show res\" to see reservations."
             echo -e "\n"

          fi # end if res_act > 0
       fi  #end NO_OPTION

    fi #res_totl > 2
 
  fi #RES Control = NONE
 # Array info, etc. 
 #http://stackoverflow.com/questions/6723426/looping-over-arrays-printing-both-index-and-value
 #http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-10.html
 #http://tldp.org/LDP/abs/html/comparison-ops.html
 #http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO.html#toc10

############################################end  RESERVATION


#################beg POST RESERVATION

#                                       Make adjustment if reservation doesn't have a queue.
##                                       -- when queue is '(null)'
                   if [[ $res_queue == '(null)' && $RESERVATION_USE == yes ]]; then
                      if [[ $queue_from == cmdline ]]; then

                         MY_QUEUE=$CMDLINE_QUEUE
                        #echo "Cmdline    queue : -p $MY_QUEUE"
                         res_list[${pr_no_que}]=`printf "$res_format3"  "Queue"           "$MY_QUEUE"           "$S_cmd_line"`
                        # NOT set in last conditional above.  Reset here.  9/26/2021
                        # ^ should already be set.  Really concerned about else. 

                      else

                         echo "Reser.     queue : $res_queue"
                         echo " "
                         echo " Error: ** You must specify a queue for this reservation. **"
                         echo "           NO queue was assigned when the reservation was made "
                         echo "           and NO queue is specified on the idev command line."
                         echo "           Specify a queue (-p option) that contains the nodes"
                         echo "           of your reservation, or ask the person who made the"
                         echo "           reservation to include a queue for the nodes."

                         exit 1
                      fi
                   fi
##                                       If $MY_QUEUE='(null)' and tries to use -p, this will not work
#

#################end POST RESERVATION

###--^DIR and RESERVATION PROCESSING (from ###MOVED DIR and RESERVATION... (from 1399)
############################################beg Dependent options
   # GET BASIC INFO (queue specific): Sockets Cores/Socket HardWare Threads per Core
  
             #Now that the queue is known, determine its Threads per Node (TpN)
             #Queue_Sockets_CoresPerSocket_HardwareThreads
   declare -a Q_S_CpS_HWT=(`sinfo -p $MY_QUEUE -o "%P %X %Y %Z" | grep -P '^'$MY_QUEUE'[\s\*]'`)
   #  Careful, Queue name may have a "*" at end. (means default queue)

   if [[ ${#Q_S_CpS_HWT[*]} == 0 ]]; then
      echo " -> Cmd line: $0 $cmd_args"
      echo " -> ERROR: The $MY_QUEUE queue is not known on this system."
      exit
   fi
  
             #Make the MPI Tasks per Node equal to the Cores per Node
   CpN=$(( ${Q_S_CpS_HWT[1]} * ${Q_S_CpS_HWT[2]} ))
   TpN=$CpN
   HWTpC=${Q_S_CpS_HWT[3]}
   PpN=$(( $CpN * $HWTpC ))

  ############################################beg  DEFINE function


  ask_queue_idevrc_tpn()
  {
     idevrc_queue_tpn=unset 
     while [[ $idevrc_queue_tpn == unset ]]; do
        # FIND OUT WHAT THE USER WANTS
        echo ""
        echo    " -> Compute nodes in the $MY_QUEUE queue of the $MY_SYS system have HyperThreading turned on."
        echo    " -> Normal HPC Applications will use no more than $CpN tasks per node (=cores/node)."
        echo    " -> Few Apps use all HyperThreads [$HWTpC (HWthreads/Core) x $CpN (Cores/Node) = $PpN )."
        echo -n " -> FOR IDEV USE: specify the default tasks/per node for this queue." 
#       echo    "($CpN suggested)."
        echo -e "\033[1;36m($CpN suggested)"; echo -e -n '\033[0m'
        if [[ $MY_SYS == knl ]]; then
        echo    " -> For KNC or KNL you might want to use less than $CpN tasks/node (e.g. 4, 8, ...)."
        fi
  
        # FIND OUT WHAT THE USER WANTS
         echo -n "Please type the tasks per node and hit return: "
         read  my_tpn
         if [[  $my_tpn =~ ^[0-9]+$ &&  $my_tpn -gt 0  &&  $my_tpn -lt 273  ]]; then
            idevrc_queue_tpn=$my_tpn
         else
            if [[  x$my_tpn == x  ]]; then
              idevrc_queue_tpn=$CpN
            else
              echo "That is not a number between 1-272."
              echo "Please enter a valid number."
            fi
         fi

         echo " -> $idevrc_queue_tpn is the number of tasks per node selected for the $MY_QUEUE queue."
         echo "idev_tpn_${MY_QUEUE}${MID} ${idevrc_queue_tpn}" >> $HOME/.idevrc

       done
       idevrc_tpn=$idevrc_queue_tpn
  }

  ############################################end  DEFINE function

if [[ ${#Q_TpN_array[*]} != 0 ]]; then
  for i in ${!Q_TpN_array[*]} ; do
    [[ ${Q_TpN_array[$i]} =~ idev_tpn_${MY_QUEUE}$MID ]] && idevrc_tpn=${Q_TpN_array[ $((i+1)) ]}
  done
fi
# idevrc_tpn may still be "unset" here


############################################beg  tpn logic

# TOTAL TASKS and NUMBER of NODES

#case 1-3
tpn_set_by=unset
                           #DEFAULT MY_NODES=1
 if [[ $opt_NODE_count == 0 && $opt_TASK_count == 0 ]]; then
   [[ -n $IDEV ]] &&  echo "case 1-3 opt_NODE_count= $opt_NODE_count  opt_TASK_Count $opt_TASK_count"
   MY_NODES=1
   res_list[${pr_no_N}]=`  printf "$res_format3"  "Nodes"           "$MY_NODES"           "$S_idev_default"`

   if [[ $idevrc_tpn != unset ]]; then
     IDEV_TASKS_PER_NODE="--tasks-per-node $idevrc_tpn"
     MY_TASKS_PER_NODE="$idevrc_tpn"
     tpn_set_by="$S_idevrc"
   else
     if [[ $HWTpC -eq 1 ]]; then   
        IDEV_TASKS_PER_NODE="--tasks-per-node $CpN"
        MY_TASKS_PER_NODE="$CpN"
        tpn_set_by="Queue default"
     else
        if [[ $idevrc_tpn == unset ]]; then
          ask_queue_idevrc_tpn
        fi 

        IDEV_TASKS_PER_NODE="--tasks-per-node $idevrc_tpn"
        MY_TASKS_PER_NODE="$idevrc_tpn"
        tpn_set_by="$S_idevrc"
     fi

   fi
 fi

#case 4
 if [[ $opt_NODE_count ==  0 && $opt_TASK_count >  0 ]]; then
   [[ -n $IDEV ]] && echo "case 4 opt_NODE_count= $opt_NODE_count  opt_TASK_Count $opt_TASK_count"
   echo " -> Cmd line: $0 $cmd_args"
   echo " -> ERROR: If total tasks (-n) and/or tasks per node (--tasks-per-node or -tpn)"
   echo "            are specified, -N (nodes) MUST be specified."

   exit
 fi

#case 5-7
 if [[ $opt_NODE_count  > 0 && $opt_TASK_count >  0 ]]; then
     [[ -n $IDEV ]] && echo "case 5-7 opt_NODE_count= $opt_NODE_count  opt_TASK_Count $opt_TASK_count"
     if [[ $opt_tasks_per_node == set ]]; then
        IDEV_TASKS_PER_NODE=" --tasks-per-node $MY_TASKS_PER_NODE"
       #tpn_set_by="$S_cmd_line --tasks-per-node"   #NEEDS LONG FORMAT
        tpn_set_by="$S_cmd_line $tpn_type"   #NEEDS LONG FORMAT
     fi
     if [[ $opt_total_tasks == set ]]; then
        IDEV_TOTAL_TASKS=" -n $MY_TOTAL_TASKS"
     else
        IDEV_TOTAL_TASKS=""
     fi

 fi

#case 8

 if [[ $opt_NODE_count > 0 && $opt_TASK_count == 0 ]]; then
   [[ -n $IDEV ]] && echo "case 8 opt_NODE_count= $opt_NODE_count  opt_TASK_Count $opt_TASK_count"
   if [[ $idevrc_tpn != unset ]]; then                       #8
     MY_TASKS_PER_NODE=$idevrc_tpn
     IDEV_TASKS_PER_NODE=" --tasks-per-node $idevrc_tpn"
     tpn_set_by="$S_idevrc"
   else
     if [[ $HWTpC -eq 1 ]]; then                             #9
       MY_TASKS_PER_NODE=$CpN
       IDEV_TASKS_PER_NODE="--tasks-per-node $CpN"
       tpn_set_by="Queue default"
     else                                                   #10
       ask_queue_idevrc_tpn
       MY_TASKS_PER_NODE=$idevrc_tpn
       IDEV_TASKS_PER_NODE="--tasks-per-node $idevrc_tpn"
       tpn_set_by="$S_idevrc"
     fi
   fi
 fi

 echo ""
 if [[ $tpn_set_by != unset ]]; then
    if [[ $tpn_set_by =~ -- ]];then
       res_list[${pr_no_tpn}]=`printf "$res_format3l" "Tasks per Node"  "$MY_TASKS_PER_NODE"  "$tpn_set_by"`
    else
       res_list[${pr_no_tpn}]=`printf "$res_format3"  "Tasks per Node"  "$MY_TASKS_PER_NODE"  "$tpn_set_by"`
    fi
fi

############################################end  tpn logic

# if [[ ${SYSTEMS_REQUIRE_USER_DEFINE_n[@]} =~ $MY_SYS ]]; then
# 
#  if [[ $opt_NODE_count == 0 && $opt_TASK_count ==  0 ]]; then
#     if [[ ${my_default_n} == unset ]]; then
# 
#       # FIND OUT WHAT THE USER WANTS
#       echo " ==> idev uses 1 $MY_SYS node by default (-N SLURM value)."
#       echo " ==> Please set the total number of tasks to use with this default (the default -n SLURM value)."
# 
#        echo -n "Please type your the default total tasks for a single node and hit return: "
#        read  my_n
#      # if [[  $my_n =~ ^[0-9]+$ &&  $my_n > 0  &&  $my_n < 273  ]]; then
#        if [[  $my_n =~ ^[0-9]+$ &&  $my_n -gt 0  &&  $my_n -lt 273  ]]; then
#           my_default_n=$my_n
#           echo " -> $my_default_n is the number of tasks selected."
#        else
#           echo "That is not a number between 1-272."
#           echo "Please enter a valid number."
#           echo "put while around this statement."
#        fi
# 
#        #echo "idev_n${MID} ${my_default_n}" >> $HOME/.idevrc
# 
#        # FIND OUT WHAT THE USER WANTS end
#     else
#        MY_TOTAL_TASKS=$my_default_n
#     fi
#  fi 
# fi


############################################beg  grace queue

#      if grace-serial queue     
if [[ $MY_QUEUE =~ grace-serial ]]; then

  squeue -p $MY_QUEUE "$squeue_opts" -u $USER | \
            awk '$3 ~ /idv[0-9][0-9][0-9][0-9][0-9]/' | \
            awk '{print $5}' | grep R >/dev/null
  if [ $? = 0 ]; then
    using_node=`squeue -p $MY_QUEUE "$squeue_opts" -u $USER | \
            awk '$3 ~ /idv[0-9][0-9][0-9][0-9][0-9]/' | \
            awk '{print $8}' `
    echo ""
    echo " -> ERROR:  Only one ONE idev interactive session allowed in $MY_QUEUE queue."
    echo ""
    echo " -> You are executing idev again in the $MY_QUEUE queue."
    echo "     In this queue only 1 idev interactive job is allowed."
    echo "     You may have multiple windows open to the job (node) for an active"
    echo "     IDEV session by opening a new window on a login node, and SSHing"
    echo "     to the node of the job with the command:"
    echo ""
    echo "                  ssh -Y $using_node   "
    echo ""
    echo " -> In a new window you can customize your environment if"
    echo "    you want to work interactively on different projects."  
    echo ""
    do_exit=yes; OPT_ERR=2
  fi
fi

############################################end  grace queue

############################################end  Dependent options


#                         Bail out if not launching or arg error
#                         Only last error value is reported in trap.
#                         But all error messages reported (above).
#------------------------------------------------------------------------------
[[ $do_exit == "yes" ]] && exit $OPT_ERR
#------------------------------------------------------------------------------

###MOVED DIR and RESERVATION PROCESSING to ###DIR and RESERVATTION PROCESSING (1162)

#################beg Check on QUEUE availability

   echo ""; echo  -n " -> Checking on the status of $MY_QUEUE queue.";
   queue_status=`sinfo -p $MY_QUEUE -o "%20P %5a" |grep $MY_QUEUE | awk '{print $2}'`
   if [[ $queue_status = "" ]]; then
     echo ""
     echo "Sorry, SOMETHING WENT WRONG INTERNALLY, ERROR 001, please report to consulting staff."
     exit
   fi
   up_status=up
   [[ ! -z ${IDEV_QUEUE_CHECK+x} ]] && up_status=xx 

if [[ $queue_status != $up_status ]]; then
   echo " NOT OK"; echo ""
   echo "      The status of the $MY_QUEUE queue is $queue_status."
   echo "      Since the status (availability) is not \"$up_status\" "
   echo "      Either exit, and use the -p option to select a different queue (in an \"up\" state)"
   echo "      or     wait in idev for the queue to come back up (not suggested)."
   echo "      or     if a reservation has been requested, select another reservation (-r res_name) or go reservationless (-r none)"; echo ""

   echo "         Partition states:"; echo ""

   sinfo -o "      %20P %5a"; echo ""

   declare -a select_values
   select_values=("exit" "wait"); select_type=exit_or_wait
   selected_value_default=exit
   selected_no_default=1
   select_one
   unset select_values
else
   echo " OK"; echo ""
fi

#################end Check on QUEUE availability

###################################  Project INFO Begin

if [[ $check_project == yes ]]; then

  #                             If no project in HOME/.idevrc
  #                             or -A option not used on cmd line
  #                             Submit a bogus job to get projects
  #                             This is the best I can do as a user!!
  #                             Hmmm.  I cannot redirect error on this.

 if [[ $MY_ACCOUNT == none || -z $MY_ACCOUNT ]]; then
   echo ""
   echo "We need a project to charge for interactive use.";
  #echo "We will be using a dummy job submission to determine your project(s).";
   echo "for a Single Project : We store \"use_default\"              in the \$HOME/.idevrc file.";
   echo "for Multiple Projects: We will store your selected project in the \$HOME/.idevrc file.";
   echo ""
  #                             Submit bogus job

   #some systems don't have a normal queue

   test_queue=normal
    [[ $MY_SYS == maverick2 ]]    && test_queue=gpu
 if [[ $IDEV_TEST != ON ]]; then
    [[ $TACC_SLURM_CONF =~ _LG ]] && test_queue=largemem512GB
 fi

cat <<EOF >/tmp/idev_acct_job_$my_pid
#!/bin/bash
#SBATCH -J acct_tes
#SBATCH -o /dev/null
#SBATCH -p $test_queue
#SBATCH -n $CpN
#SBATCH -N 1
#SBATCH -t 00:01:00
EOF

   sbatch   /tmp/idev_acct_job_$my_pid >& /tmp/idev_acct_job_output_$my_pid

   [[ $IDEV_DEBUG != ON ]] && rm -rf  /tmp/idev_acct_job_$my_pid


   #                            Extract Projects from file in /tmp
   #                            (Get_projects.pl script removes it.)
   #  echo "HERE   idev_utils get_projects $my_pid ";
   project_string=`$DIR/idev_utils get_projects $my_pid`;
   project_array=( $project_string )
   #                            Now ask user which one he wants to use if count>1.

   if [[ ${#project_array[@]} > 1 ]]; then

     echo "Please select the NUMBER of the project you want to charge.\n";
     count=1;
     count=1;
     for i in "${project_array[@]}"
     do
        echo $count $i
        count=$(( $count + 1 ))
     done

     echo "Please type the NUMBER(default=1) and hit return: ";
     read project_no
     if [[ "$project_no" == "" ]]; then project_no=1; fi

     if [ $project_no -eq $project_no 2> /dev/null ]; then
       echo ""  #keep shell happy
     else
       echo "You didn't type a number.  You typed $project_no. Try again."
       exit 1
     fi

     echo " -> $project_no is the project number you selected."

     if [[ $project_no -gt 0 && $project_no -le ${#project_array[@]} ]]; then
#    if [[ $project_no > 0 && $project_no <= ${project_array[@]} ]]; then
       array_no=$(( $project_no - 1));
       echo " OK I'll use ${project_array[$array_no]}. Thanks. "
       echo "idev_project${MID} ${project_array[$array_no]}" >> $HOME/.idevrc
       MY_ACCOUNT=${project_array[$array_no]}
     else
       echo "$project_no is not a valid number, please try again."
       exit 1
     fi

     IDEV_ACCOUNT="-A  $MY_ACCOUNT"
     res_list[${pr_no_A}]=`  printf "$res_format3"  "Project"         "$MY_ACCOUNT"         "$S_idevrc"`

   else
   #  echo " You have a single project named ${project_array[0]}."
   #  MY_ACCOUNT=${project_array[0]}
   #  echo "idev_project${MID} ${project_array[$array_no]}" >> $HOME/.idevrc
      if [[ x$project_string == x ]]; then
        echo "Accounting appears not to be functioning on $MY_SYS."
        echo "Default accounting will be used."
        echo "NOTE:  idev_project${MID} is being set to use_default in .idevrc."
        echo "NOTE:  When accounting is functioning again, remove the idev_project${MID} line."
        echo "idev_project${MID} use_default" >> $HOME/.idevrc
        echo "NOTE:  When accounting is functioning again, remove the above project line." >>$HOME/.idevrc
        IDEV_ACCOUNT=" "
        MY_ACCOUNT="use_default"
      else
        echo " You have a single project which we will use as the default."
#IS THIS CORRECT????  WHY NOT USE "use_default"
        MY_ACCOUNT=${project_array[0]}
        echo "idev_project${MID} ${project_array[$array_no]}" >> $HOME/.idevrc

        IDEV_ACCOUNT=" "
        res_list[${pr_no_A}]=`  printf "$res_format3"  "Project"         "($MY_ACCOUNT)"         "SLURM default"`

       #MY_ACCOUNT=${project_array[0]}
       #echo "idev_project${MID} use_default" >> $HOME/.idevrc
       #res_list[${pr_no_A}]=`  printf "$res_format3"  "Project"         "($MY_ACCOUNT)"         "SLURM default"`

      fi
   fi

   [[ $IDEV_DEBUG != ON ]] && rm -rf /tmp/idev_acct_job_output_$my_pid

 fi
fi


###################################  Project INFO End


#################################### List Options Begin
   for i in ${!res_list[*]}; do
     echo   "${res_list[$i]}"
   done
#################################### List Options End
[[ $IDEV_DEBUG == LIST ]] && exit 


####################################beg Submit SLURM batch job

mult_proj_err=" ->ERROR: You have multiple projects to charge to"
[[ -n $IDEV ]] && echo "#SBATCH -p  $MY_QUEUE"
[[ -n $IDEV ]] && echo "#SBATCH -N  ${MY_NODES}"
[[ -n $IDEV ]] && echo "#SBATCH $IDEV_TOTAL_TASKS"
[[ -n $IDEV ]] && echo "#SBATCH $IDEV_TASKS_PER_NODE"
[[ -n $IDEV ]] && echo "#SBATCH $IDEV_ACCOUNT"
[[ -n $IDEV ]] && echo MYSLURMARGS: $IDEV_SLURM_ARGS
[[ -n $IDEV ]] && echo $MY_RESERVATION
[[ -n $IDEV ]] && echo $MY_EMAIL

[[ -n $IDEV ]] &&  exit

#cat >/tmp/myjob_$USER.$$ <<EOF
cat >$HOME/.slurm/myjob_$USER.$$ <<EOF
#!/bin/${idev_login_shell}
#SBATCH -J  ${JOB_NAME}
#SBATCH -o  $HOME/.slurm/${JOB_NAME}.o%j
#SBATCH -p  $MY_QUEUE
#SBATCH -t  $MY_hhmmss_TIME
##-##
#SBATCH -N  ${MY_NODES}
#SBATCH $IDEV_TOTAL_TASKS
#SBATCH $IDEV_TASKS_PER_NODE
#SBATCH $IDEV_ACCOUNT
##-##
$IDEV_SLURM_ARGS

$MY_RESERVATION
$MY_EMAIL

$idev_pwd_cmd
$idev_rm_perl5
#                         Remove old files (needed for grace-serial queue).
rm -rf /tmp/idev_${USER}_${idev_login_shell}_env.[0-9]*
$DIR/idev_utils env_replication ${idev_login_shell} \$SLURM_JOB_ID
#                         This provides a source file for old and new /etc/profile.d/*idev.sh/tcsh scripts
$DOTHIS cp /tmp/idev_${USER}_${idev_login_shell}_env.\${SLURM_JOB_ID} /tmp/idev_${idev_login_shell}_env.\${SLURM_JOB_ID} 
$CREATE_NODE_LIST_CMD
sleep $job_sleep

EOF
#############################END of BATCH SUBMISSION SCRIPT

# EXIT HERE for checking submissions
if [[ ! -z ${IDEV_RESERVATION_TEST+x} ]]; then
   grep -i reservation $HOME/.slurm/myjob_$USER.$$
   exit
fi
[[ ! -z ${IDEV_QUEUE_CHECK+x} ]] && exit

#############################SUBMIT

#sbatch /tmp/myjob_$USER.$$
sbatch $HOME/.slurm/myjob_$USER.$$ 2>&1 | tee /tmp/idev_submit_${USER}_$my_pid
sbatch_status=${PIPESTATUS[0]}

####################################end Submit SLURM batch job

if [[ $sbatch_status != 0 ]]; then
   a=" idev detected an error in your resource request (see details above):\n "
   b=" Here is the command you executed:\n   $0 $cmd_args \n"
   exit_msg=${a}${b}
            
#                                     Try this again, and analyze error report.
   grep  "$mult_proj_err"  /tmp/idev_submit_${USER}_$my_pid >& /dev/null
   if [[ $? == 0 && $MY_ACCOUNT =~ use_default ]]; then
       exit_msg=" "
       echo ""
       echo " -> IDEV found one of the following on $MY_SYS:"
       echo " **     You now have more than one account project        **"
       echo " **     Specifying no account project is no longer valid. **"
       echo " ** The default project is being removed from ~/.idevrc.  **"
       echo " -> Your old .idevrc has been moved to .idevrc_$$_safety " 
       echo ""
       echo " -> EXECUTE IDEV AGAIN TO SELECT A NEW DEFAULT ACCOUNT.   **"
       echo " ** and begin your next idev session.                     **"
       echo ""

       sed  "/idev_project${MID}\s/d"      $HOME/.idevrc |
       sed  "/remove the above project/d"> $HOME/.idevrc_$$
       mv   $HOME/.idevrc                  $HOME/.idevrc_$$_safety
       mv   $HOME/.idevrc_$$               $HOME/.idevrc

   fi

   [[ $IDEV_DEBUG != ON ]] && rm -rf /tmp/idev_submit_${USER}_$my_pid
   [[ $IDEV_DEBUG != ON ]] && rm -rf $HOME/.slurm/myjob_$USER.$$
   exit
fi

   [[ $IDEV_DEBUG != ON ]] && rm -rf /tmp/idev_submit_${USER}_$my_pid
 
if  [ ! -d "$IDEV_KEEP_MY_JOB_DIR" ] ;then
   [[ $IDEV_DEBUG != ON ]] && rm -rf $HOME/.slurm/myjob_$USER.$$
else
   cp     $HOME/.slurm/myjob_$USER.$$ $IDEV_KEEP_MY_JOB_DIR/myjob_$USER.$$
   rm -rf $HOME/.slurm/myjob_$USER.$$
fi
 
job_id=none
job_submitted=yes
  
echo -e "\n -> After your idev job begins to run, a command prompt will appear,"
echo -e   " -> and you can begin your interactive development session. "
echo -e   " -> We will report the job status every $monitor_sleep seconds: (PD=pending, R=running).\n"
torf=1
#                             Environment file check: parameters.
found_env_file=1
time_waited_env_file=0
sleep_time_env_file=5

####################################beg Wait on job

while [ $torf == 1 ]
do
  
   squeue -p $MY_QUEUE "$squeue_opts" -u $USER | grep "$JOB_NAME" >& /dev/null
   if [ $? ]; then
      mystatus=`squeue -p $MY_QUEUE "$squeue_opts" -u $USER | awk '$3 ~ /'"$JOB_NAME"'/ { print $5}'`
      echo " -> job status:  $mystatus"
      job_id=`squeue -p $MY_QUEUE "$squeue_opts" -u $USER | awk '$3 ~ /'"$JOB_NAME"'/ { print $1}'`
      if [ x"$mystatus" == "xR" ]; then
         master_node=`squeue -p $MY_QUEUE "$squeue_opts" -u $USER | awk '$3 ~ /'"$JOB_NAME"'/ { print $8}'`
               JOBID=`squeue -p $MY_QUEUE "$squeue_opts" -u $USER | awk '$3 ~ /'"$JOB_NAME"'/ { print $1}'`
  
         master_node=`echo $master_node | sed 's/,.*//'`; 
         if [[ $master_node =~ \[ ]]; then    #Has form c557-[100-104]
           master_node=`echo $master_node | sed 's/\[//'`
           master_node=`echo $master_node | sed -e 's/\(^........\).*/\1/'`
         fi
         nodestring=$master_node
  

         echo -e "\n -> Job is now running on masternode= $master_node...OK"
         echo -ne  " -> Sleeping for $sleep_after_run seconds."
         sleep $sleep_after_run
         echo "..OK"
#                                            Get master and rank 0 nodes
         master_node=`echo $nodestring | sed 's/.'"$MY_SYS"'.*//'`

#                                            Set ssh to the node of choice
#                                            Might be more general later.
#                                            May need this SGE trick later
         [[ $use_node_type == master ]] && node=$master_node
         if [[ $use_node_type == rank0  ]] ; then 
            rank0_node=`head -n 1 $HOME/.slurm/job.$JOBID.hostlist.*`
            rank0_node=${rank0_node%%.*}
            node=$rank0_node
         fi
#                                            Check to make sure environment file
#                                            is in /tmp on the compute node.
#                                            Multi-node jobs may take up to 25 sec.
#                                            before the script is started.
         echo -ne " -> Checking to make sure your job has initialized an env for you."
####
         while [ $found_env_file == 1 ]; do
         
             ssh -o "StrictHostKeyChecking no" $node "ls /tmp/idev_${USER}_${idev_login_shell}_env.${JOBID}" >& /dev/null
             if [[ $? == 0 ]]; then
                found_env_file=0
                if [[ $time_waited_env_file > 0 ]]; then
                   echo ""
                   echo " -> Yahoo! The environment is now in place...OK"
                else
                   echo "...OK"
                fi
             else
         
                if [[ $time_waited_env_file == 0 ]]; then
                  echo ""
                  echo " -> Hmm, for multi-node jobs, (or when $BATCH_SYS is sleepy) we need to"
                  echo " ->      give $BATCH_SYS more time to kick things off (maybe 20 sec.). "
                  echo " ->      I'll check every $sleep_time_env_file secs."
                  echo ""
                fi
                echo   " ->      Time waited (sec.) : $time_waited_env_file"
                sleep $sleep_time_env_file
                time_waited_env_file=$(( $time_waited_env_file + 5 ))
             fi
         done
  
####
  
         echo " -> Creating interactive terminal session (login) on $use_node_type node $node."
#                                            Finally!
         echo -en "\007"
         echo " -> ssh -Y $MY_SSH_ARGS -o \"StrictHostKeyChecking no\" $node"
         ssh -Y $MY_SSH_ARGS -o "StrictHostKeyChecking no" $node
         echo ""
         exit
      fi
   fi

sleep $monitor_sleep
done
####################################end Wait on job




#trapping
#http://rimuhosting.com/knowledgebase/linux/misc/trapping-ctrl-c-in-bash
#http://www.linuxjournal.com/content/use-bash-trap-statement-cleanup-temporary-files
